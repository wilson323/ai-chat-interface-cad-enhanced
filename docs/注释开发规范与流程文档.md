# 注释开发规范与流程文档

- 目标：提高可读性与可维护性，降低心智负担，支撑审查与自动化。
- 范畴：TypeScript/React/Next.js/Node 边界清晰，遵循 Clean Architecture。

## 基本原则
- 必要即充分：仅为复杂/非直觉的代码添加注释；解释“为什么”，少写“是什么”。
- 结构优先：文件顶部加模块职责简述；复杂函数添加 JSDoc。
- 一致性：统一语义、统一术语、统一英文/中文标点（代码内优先英文）。

## JSDoc 模板
- 函数（复杂或公共导出）：
```ts
/**
 * 功能/意图（Why）
 * 关键约束/边界条件
 * 错误处理与降级策略
 * @param foo 描述
 * @returns 描述
 */
export const doSomething = (foo: string): Result => { /* ... */ }
```
- 类/服务：职责、线程/并发模型、资源生命周期（init/dispose）。
- API Route：请求/响应契约、限流/超时/鉴权说明。

## 错误处理与日志
- try-catch 需包含明确的上下文信息；使用统一 logger；避免吞错。
- 对外暴露稳定错误码/文案；内部保留栈与上下文。

## Clean Architecture 映射
- UI 层：纯渲染与交互，不含业务规则。
- 应用层：用例编排、流程控制、错误边界。
- 领域层：核心模型与规则，纯函数化优先。
- 基础设施：外部系统集成（DB/缓存/HTTP/文件）。

## 文档化要求
- 新模块/重要修改：PR 必须更新对应 docs/ 指南或在此文档追加章节。
- 在代码内添加“变更缘由”块，注明变更背景与兼容性影响。

## 审查清单（片段）
- 命名是否表达意图且一致（camelCase、命名导出）。
- 是否存在多余注释/过期注释。
- 是否覆盖边界与异常路径；是否提供降级策略。
- 是否违背无 mock 原则；是否具备可测试性（依赖可替换）。

## 示例对照

### 差示例（缺少 JSDoc、命名与错误处理不规范）
```ts
export const run = (a: any, b: any) => {
  // 计算
  const r = a + b
  try {
    return fetch('/api/do', { method: 'POST', body: JSON.stringify({ r }) })
  } catch (e) {
    console.log(e)
    return null
  }
}
```

### 好示例（JSDoc 完整、命名清晰、类型与错误处理规范、命名导出、Array<T>）
```ts
import { z } from 'zod'

const doRequestSchema = z.object({
  result: z.number(),
})

/**
 * 计算业务结果并调用后端接口提交
 * 约束：a、b 必须为有限数值；调用后端失败时提供稳定降级结果
 * 错误处理：捕获并记录上下文，不吞错；返回明确的错误类型
 * @param firstOperand 第一个加数
 * @param secondOperand 第二个加数
 * @returns 提交是否成功的布尔值
 */
export const submitBusinessResult = async (
  firstOperand: number,
  secondOperand: number
): Promise<boolean> => {
  if (!Number.isFinite(firstOperand) || !Number.isFinite(secondOperand)) {
    throw new Error('Invalid operands: must be finite numbers')
  }
  const result = firstOperand + secondOperand
  try {
    const payload = doRequestSchema.parse({ result })
    const response = await fetch('/api/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`)
    }
    return true
  } catch (error) {
    // 统一 logger：此处仅示例
    console.error('submitBusinessResult failed', { firstOperand, secondOperand, error })
    return false
  }
}
```

### API Route 片段好示例（契约、鉴权、限流、错误结构）
```ts
/**
 * 请求/响应契约：POST /api/things { id: string }
 * 超时：10s；鉴权：Bearer；限流：Upstash Redis；错误结构：{ code, message }
 */
export const POST = async (req: Request): Promise<Response> => {
  try {
    const input = await req.json()
    if (typeof input?.id !== 'string') {
      return Response.json({ code: 'BAD_REQUEST', message: 'id required' }, { status: 400 })
    }
    // ... 业务逻辑
    return Response.json({ ok: true })
  } catch (error) {
    return Response.json({ code: 'INTERNAL_ERROR', message: 'unexpected error' }, { status: 500 })
  }
}
```


