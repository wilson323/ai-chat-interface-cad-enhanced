---
alwaysApply: true
---

# ZK-Agent æµ‹è¯•è§„èŒƒä¸è´¨é‡ä¿è¯æ ‡å‡†

## ğŸ“‹ æµ‹è¯•æ¡†æ¶ç»Ÿä¸€æ ‡å‡†

åŸºäº [æµ‹è¯•æ ‡å‡†æ–‡æ¡£](mdc:docs/testing-standard.md)ï¼Œç¡®ä¿é¡¹ç›®æµ‹è¯•è´¨é‡å’Œè¦†ç›–ç‡ã€‚

### æµ‹è¯•æ¡†æ¶é€‰æ‹©
- **å‰ç«¯æµ‹è¯•**: ç»Ÿä¸€ä½¿ç”¨ Vitest ä½œä¸ºä¸»è¦æµ‹è¯•æ¡†æ¶
- **ç«¯åˆ°ç«¯æµ‹è¯•**: ä½¿ç”¨ Playwright è¿›è¡ŒE2Eæµ‹è¯•
- **åç«¯æµ‹è¯•**: ä½¿ç”¨ pytest è¿›è¡ŒPythonæµ‹è¯•
- **ç¦æ­¢**: å¼•å…¥å…¶ä»–æµ‹è¯•æ¡†æ¶ (å¦‚ Jestã€Mocha ç­‰)

### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚
```typescript
interface CoverageRequirements {
  minimumCoverage: {
    unitTests: 80;        // å•å…ƒæµ‹è¯•æœ€ä½è¦†ç›–ç‡
    integrationTests: 60; // é›†æˆæµ‹è¯•æœ€ä½è¦†ç›–ç‡
    criticalPaths: 90;    // å…³é”®ä¸šåŠ¡è·¯å¾„è¦†ç›–ç‡
    e2eTests: 50;         // ç«¯åˆ°ç«¯æµ‹è¯•è¦†ç›–ç‡
  };

  qualityGates: {
    codeQuality: 90;      // ä»£ç è´¨é‡è¯„åˆ†
    testReliability: 95;  // æµ‹è¯•å¯é æ€§
    performanceRegression: 5; // æ€§èƒ½å›å½’é˜ˆå€¼(%)
  };
}
```

## ğŸ§ª å•å…ƒæµ‹è¯•è§„èŒƒ

### Vitestå•å…ƒæµ‹è¯•æ ‡å‡†
```typescript
// âœ… æ­£ç¡®çš„Vitestæµ‹è¯•ç»“æ„
import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest';
import { TestUtils, withTestEnvironment } from '@/lib/testing/unified-test-utils';
import { UserService } from '@/lib/services/user-service';
import type { UserProfile, CreateUserRequest } from '@/types/user';

describe('UserService', () => {
  let userService: UserService;
  let mockDatabase: any;

  beforeAll(async () => {
    // åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
    TestUtils.initialize();
    mockDatabase = TestUtils.createMockDatabase();
    userService = new UserService(mockDatabase);
  });

  afterAll(async () => {
    // æ¸…ç†æµ‹è¯•ç¯å¢ƒ
    await TestUtils.cleanup();
  });

  describe('createUser', () => {
    it('åº”è¯¥æˆåŠŸåˆ›å»ºç”¨æˆ·å¹¶è¿”å›ç”¨æˆ·ä¿¡æ¯', async () => {
      // Given - å‡†å¤‡æµ‹è¯•æ•°æ®
      const createRequest: CreateUserRequest = {
        name: 'å¼ ä¸‰',
        email: 'zhangsan@example.com',
        password: 'securePassword123'
      };

      const expectedUser: UserProfile = {
        id: 'user-123',
        name: 'å¼ ä¸‰',
        email: 'zhangsan@example.com',
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // æ¨¡æ‹Ÿæ•°æ®åº“è¡Œä¸º
      mockDatabase.users.create.mockResolvedValue(expectedUser);

      // When - æ‰§è¡Œæµ‹è¯•
      const result = await userService.createUser(createRequest);

      // Then - éªŒè¯ç»“æœ
      expect(result.success).toBe(true);
      expect(result.data).toEqual(expectedUser);
      expect(result.data.email).toBe(createRequest.email);
      expect(mockDatabase.users.create).toHaveBeenCalledWith({
        name: createRequest.name,
        email: createRequest.email,
        passwordHash: expect.any(String)
      });
    });

    it('åº”è¯¥å¤„ç†é‚®ç®±å·²å­˜åœ¨çš„é”™è¯¯æƒ…å†µ', async () => {
      // Given
      const duplicateRequest: CreateUserRequest = {
        name: 'æå››',
        email: 'duplicate@example.com',
        password: 'password123'
      };

      mockDatabase.users.create.mockRejectedValue(
        new Error('Email already exists')
      );

      // When & Then
      const result = await userService.createUser(duplicateRequest);

      expect(result.success).toBe(false);
      expect(result.error).toContain('é‚®ç®±å·²å­˜åœ¨');
    });

    it('åº”è¯¥éªŒè¯è¾“å…¥å‚æ•°å¹¶æ‹’ç»æ— æ•ˆæ•°æ®', async () => {
      // Given - æ— æ•ˆçš„ç”¨æˆ·æ•°æ®
      const invalidRequest = {
        name: '',
        email: 'invalid-email',
        password: '123' // å¯†ç å¤ªçŸ­
      } as CreateUserRequest;

      // When & Then
      await expect(userService.createUser(invalidRequest))
        .rejects.toThrow('Invalid user data');
    });
  });

  describe('getUserById', () => {
    it('åº”è¯¥è¿”å›å­˜åœ¨çš„ç”¨æˆ·ä¿¡æ¯', withTestEnvironment(async () => {
      // Given
      const userId = 'user-123';
      const expectedUser: UserProfile = {
        id: userId,
        name: 'å¼ ä¸‰',
        email: 'zhangsan@example.com',
        createdAt: new Date(),
        updatedAt: new Date()
      };

      mockDatabase.users.findById.mockResolvedValue(expectedUser);

      // When
      const result = await userService.getUserById(userId);

      // Then
      expect(result).toEqual(expectedUser);
      expect(mockDatabase.users.findById).toHaveBeenCalledWith(userId);
    }));

    it('åº”è¯¥åœ¨ç”¨æˆ·ä¸å­˜åœ¨æ—¶è¿”å›null', async () => {
      // Given
      const nonExistentUserId = 'non-existent';
      mockDatabase.users.findById.mockResolvedValue(null);

      // When
      const result = await userService.getUserById(nonExistentUserId);

      // Then
      expect(result).toBeNull();
    });
  });
});
```

### Pythonå•å…ƒæµ‹è¯•æ ‡å‡†
```python
# âœ… æ­£ç¡®çš„pytestæµ‹è¯•ç»“æ„
import pytest
import asyncio
from unittest.mock import Mock, patch, AsyncMock
from typing import Dict, Any, List

from app.services.ai_service import AIService
from app.models.agent import Agent, AgentConfig
from app.exceptions import AIServiceError, ValidationError
from tests.fixtures import sample_agent_config, mock_llm_client


class TestAIService:
    """AIæœåŠ¡æµ‹è¯•ç±»

    æµ‹è¯•AIæœåŠ¡çš„æ ¸å¿ƒåŠŸèƒ½ï¼ŒåŒ…æ‹¬æ™ºèƒ½ä½“åˆ›å»ºã€å¯¹è¯å¤„ç†ã€é”™è¯¯å¤„ç†ç­‰ã€‚
    """

    @pytest.fixture
    def ai_service(self) -> AIService:
        """åˆ›å»ºAIæœåŠ¡å®ä¾‹"""
        return AIService()

    @pytest.fixture
    def mock_agent(self) -> Agent:
        """åˆ›å»ºæ¨¡æ‹Ÿæ™ºèƒ½ä½“"""
        return Agent(
            id="agent-123",
            name="æµ‹è¯•æ™ºèƒ½ä½“",
            config=AgentConfig(
                model="gpt-4",
                temperature=0.7,
                max_tokens=2000
            )
        )

    @pytest.mark.asyncio
    async def test_create_agent_success(
        self,
        ai_service: AIService,
        sample_agent_config: AgentConfig
    ):
        """æµ‹è¯•æˆåŠŸåˆ›å»ºæ™ºèƒ½ä½“"""
        # Given
        with patch.object(ai_service.db, 'save_agent') as mock_save:
            mock_save.return_value = "agent-123"

            # When
            result = await ai_service.create_agent(sample_agent_config)

            # Then
            assert result.success is True
            assert result.agent_id == "agent-123"
            assert result.agent.name == sample_agent_config.name
            mock_save.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_agent_validation_error(self, ai_service: AIService):
        """æµ‹è¯•æ™ºèƒ½ä½“åˆ›å»ºæ—¶çš„éªŒè¯é”™è¯¯"""
        # Given - æ— æ•ˆé…ç½®
        invalid_config = AgentConfig(
            name="",  # ç©ºåç§°
            model="invalid-model",  # æ— æ•ˆæ¨¡å‹
            temperature=-1.0  # æ— æ•ˆæ¸©åº¦
        )

        # When & Then
        with pytest.raises(ValidationError) as exc_info:
            await ai_service.create_agent(invalid_config)

        assert "åç§°ä¸èƒ½ä¸ºç©º" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_chat_with_agent_success(
        self,
        ai_service: AIService,
        mock_agent: Agent,
        mock_llm_client: AsyncMock
    ):
        """æµ‹è¯•ä¸æ™ºèƒ½ä½“æˆåŠŸå¯¹è¯"""
        # Given
        message = "ä½ å¥½ï¼Œè¯·ä»‹ç»ä¸€ä¸‹è‡ªå·±"
        expected_response = "ä½ å¥½ï¼æˆ‘æ˜¯ä¸€ä¸ªAIåŠ©æ‰‹ï¼Œå¯ä»¥å¸®åŠ©æ‚¨è§£å†³å„ç§é—®é¢˜ã€‚"

        mock_llm_client.chat_completion.return_value = {
            "choices": [{"message": {"content": expected_response}}]
        }

        with patch.object(ai_service, 'llm_client', mock_llm_client):
            # When
            response = await ai_service.chat_with_agent(
                agent_id=mock_agent.id,
                message=message,
                session_id="session-123"
            )

            # Then
            assert response.success is True
            assert response.content == expected_response
            assert response.session_id == "session-123"
            mock_llm_client.chat_completion.assert_called_once()

    @pytest.mark.asyncio
    async def test_chat_with_nonexistent_agent(self, ai_service: AIService):
        """æµ‹è¯•ä¸ä¸å­˜åœ¨çš„æ™ºèƒ½ä½“å¯¹è¯"""
        # Given
        nonexistent_agent_id = "nonexistent-agent"

        with patch.object(ai_service.db, 'get_agent') as mock_get:
            mock_get.return_value = None

            # When & Then
            with pytest.raises(AIServiceError) as exc_info:
                await ai_service.chat_with_agent(
                    agent_id=nonexistent_agent_id,
                    message="æµ‹è¯•æ¶ˆæ¯",
                    session_id="session-123"
                )

            assert "æ™ºèƒ½ä½“ä¸å­˜åœ¨" in str(exc_info.value)

    @pytest.mark.parametrize("temperature,expected_valid", [
        (0.0, True),
        (0.5, True),
        (1.0, True),
        (-0.1, False),
        (1.1, False),
        (2.0, False)
    ])
    def test_validate_temperature(
        self,
        ai_service: AIService,
        temperature: float,
        expected_valid: bool
    ):
        """æµ‹è¯•æ¸©åº¦å‚æ•°éªŒè¯"""
        # When
        is_valid = ai_service._validate_temperature(temperature)

        # Then
        assert is_valid == expected_valid

    @pytest.mark.performance
    async def test_concurrent_chat_performance(
        self,
        ai_service: AIService,
        mock_agent: Agent
    ):
        """æµ‹è¯•å¹¶å‘å¯¹è¯æ€§èƒ½"""
        # Given
        concurrent_count = 50
        message = "æ€§èƒ½æµ‹è¯•æ¶ˆæ¯"

        with patch.object(ai_service, 'chat_with_agent') as mock_chat:
            mock_chat.return_value = AsyncMock(
                success=True,
                content="å“åº”æ¶ˆæ¯",
                latency=0.1
            )

            # When
            start_time = asyncio.get_event_loop().time()
            tasks = [
                ai_service.chat_with_agent(
                    agent_id=mock_agent.id,
                    message=f"{message}-{i}",
                    session_id=f"session-{i}"
                )
                for i in range(concurrent_count)
            ]

            results = await asyncio.gather(*tasks)
            end_time = asyncio.get_event_loop().time()

            # Then
            assert len(results) == concurrent_count
            assert all(result.success for result in results)

            total_time = end_time - start_time
            assert total_time < 5.0  # 50ä¸ªå¹¶å‘è¯·æ±‚åº”åœ¨5ç§’å†…å®Œæˆ
```

## ğŸ”— é›†æˆæµ‹è¯•è§„èŒƒ

### APIé›†æˆæµ‹è¯•æ ‡å‡†
```typescript
// âœ… APIé›†æˆæµ‹è¯•ç¤ºä¾‹
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { IntegrationTestUtils } from '@/lib/testing/integration-utils';
import { TestServer } from '@/lib/testing/test-server';
import { ApiClient } from '@/lib/api/api-client';

describe('ç”¨æˆ·ç®¡ç† API é›†æˆæµ‹è¯•', () => {
  let testServer: TestServer;
  let apiClient: ApiClient;
  let testUtils: IntegrationTestUtils;

  beforeAll(async () => {
    // å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨
    testServer = new TestServer();
    await testServer.start();

    // åˆå§‹åŒ–æµ‹è¯•å·¥å…·
    testUtils = new IntegrationTestUtils();
    await testUtils.setupTestDatabase();

    // åˆ›å»ºAPIå®¢æˆ·ç«¯
    apiClient = new ApiClient({
      baseUrl: testServer.getBaseUrl(),
      timeout: 5000
    });
  });

  afterAll(async () => {
    await testUtils.cleanupTestDatabase();
    await testServer.stop();
  });

  describe('POST /api/users', () => {
    it('åº”è¯¥æˆåŠŸåˆ›å»ºç”¨æˆ·å¹¶è¿”å›ç”¨æˆ·ä¿¡æ¯', async () => {
      // Given
      const userData = {
        name: 'é›†æˆæµ‹è¯•ç”¨æˆ·',
        email: 'integration@test.com',
        password: 'SecurePassword123!'
      };

      // When
      const response = await apiClient.post('/api/users', userData);

      // Then
      expect(response.status).toBe(201);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toMatchObject({
        name: userData.name,
        email: userData.email,
        id: expect.any(String),
        createdAt: expect.any(String)
      });
      expect(response.data.data).not.toHaveProperty('password');
    });

    it('åº”è¯¥æ‹’ç»é‡å¤çš„é‚®ç®±åœ°å€', async () => {
      // Given - å…ˆåˆ›å»ºä¸€ä¸ªç”¨æˆ·
      const userData = {
        name: 'ç”¨æˆ·1',
        email: 'duplicate@test.com',
        password: 'Password123!'
      };

      await apiClient.post('/api/users', userData);

      // When - å°è¯•åˆ›å»ºç›¸åŒé‚®ç®±çš„ç”¨æˆ·
      const duplicateData = {
        ...userData,
        name: 'ç”¨æˆ·2'
      };

      // Then
      await expect(apiClient.post('/api/users', duplicateData))
        .rejects.toMatchObject({
          response: {
            status: 409,
            data: {
              success: false,
              error: expect.stringContaining('é‚®ç®±å·²å­˜åœ¨')
            }
          }
        });
    });
  });

  describe('GET /api/users/:id', () => {
    it('åº”è¯¥è¿”å›å­˜åœ¨çš„ç”¨æˆ·ä¿¡æ¯', async () => {
      // Given - å…ˆåˆ›å»ºä¸€ä¸ªç”¨æˆ·
      const createResponse = await apiClient.post('/api/users', {
        name: 'æŸ¥è¯¢æµ‹è¯•ç”¨æˆ·',
        email: 'query@test.com',
        password: 'Password123!'
      });

      const userId = createResponse.data.data.id;

      // When
      const response = await apiClient.get(`/api/users/${userId}`);

      // Then
      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toMatchObject({
        id: userId,
        name: 'æŸ¥è¯¢æµ‹è¯•ç”¨æˆ·',
        email: 'query@test.com'
      });
    });

    it('åº”è¯¥åœ¨ç”¨æˆ·ä¸å­˜åœ¨æ—¶è¿”å›404', async () => {
      // Given
      const nonExistentId = 'non-existent-user-id';

      // When & Then
      await expect(apiClient.get(`/api/users/${nonExistentId}`))
        .rejects.toMatchObject({
          response: {
            status: 404,
            data: {
              success: false,
              error: expect.stringContaining('ç”¨æˆ·ä¸å­˜åœ¨')
            }
          }
        });
    });
  });
});
```

## ğŸ­ ç«¯åˆ°ç«¯æµ‹è¯•è§„èŒƒ

### Playwright E2Eæµ‹è¯•æ ‡å‡†
```typescript
// âœ… Playwrightç«¯åˆ°ç«¯æµ‹è¯•ç¤ºä¾‹
import { test, expect } from '@playwright/test';
import { LoginPage } from '@/e2e/pages/login-page';
import { DashboardPage } from '@/e2e/pages/dashboard-page';
import { UserManagementPage } from '@/e2e/pages/user-management-page';

test.describe('ç”¨æˆ·ç®¡ç†ç«¯åˆ°ç«¯æµ‹è¯•', () => {
  let loginPage: LoginPage;
  let dashboardPage: DashboardPage;
  let userManagementPage: UserManagementPage;

  test.beforeEach(async ({ page }) => {
    loginPage = new LoginPage(page);
    dashboardPage = new DashboardPage(page);
    userManagementPage = new UserManagementPage(page);

    // ç™»å½•åˆ°ç³»ç»Ÿ
    await loginPage.goto();
    await loginPage.login('admin@test.com', 'AdminPassword123!');
    await expect(page).toHaveTitle('ZK-Agent Dashboard');
  });

  test('åº”è¯¥èƒ½å¤Ÿåˆ›å»ºæ–°ç”¨æˆ·', async ({ page }) => {
    // Given - å¯¼èˆªåˆ°ç”¨æˆ·ç®¡ç†é¡µé¢
    await dashboardPage.navigateToUserManagement();
    await expect(page.getByRole('heading', { name: 'ç”¨æˆ·ç®¡ç†' })).toBeVisible();

    // When - åˆ›å»ºæ–°ç”¨æˆ·
    await userManagementPage.clickCreateUser();
    await userManagementPage.fillUserForm({
      name: 'E2Eæµ‹è¯•ç”¨æˆ·',
      email: 'e2e@test.com',
      password: 'E2EPassword123!',
      role: 'user'
    });
    await userManagementPage.submitUserForm();

    // Then - éªŒè¯ç”¨æˆ·åˆ›å»ºæˆåŠŸ
    await expect(page.getByText('ç”¨æˆ·åˆ›å»ºæˆåŠŸ')).toBeVisible();
    await expect(page.getByText('E2Eæµ‹è¯•ç”¨æˆ·')).toBeVisible();
    await expect(page.getByText('e2e@test.com')).toBeVisible();
  });

  test('åº”è¯¥èƒ½å¤Ÿç¼–è¾‘ç”¨æˆ·ä¿¡æ¯', async ({ page }) => {
    // Given - ç¡®ä¿æœ‰ç”¨æˆ·å­˜åœ¨
    await dashboardPage.navigateToUserManagement();

    // å¦‚æœæ²¡æœ‰ç”¨æˆ·ï¼Œå…ˆåˆ›å»ºä¸€ä¸ª
    const userCount = await page.locator('[data-testid="user-row"]').count();
    if (userCount === 0) {
      await userManagementPage.createTestUser({
        name: 'å¾…ç¼–è¾‘ç”¨æˆ·',
        email: 'edit@test.com',
        password: 'Password123!'
      });
    }

    // When - ç¼–è¾‘ç”¨æˆ·
    await userManagementPage.editFirstUser();
    await userManagementPage.updateUserName('å·²ç¼–è¾‘çš„ç”¨æˆ·å');
    await userManagementPage.submitUserForm();

    // Then - éªŒè¯ç¼–è¾‘æˆåŠŸ
    await expect(page.getByText('ç”¨æˆ·ä¿¡æ¯æ›´æ–°æˆåŠŸ')).toBeVisible();
    await expect(page.getByText('å·²ç¼–è¾‘çš„ç”¨æˆ·å')).toBeVisible();
  });

  test('åº”è¯¥èƒ½å¤Ÿåˆ é™¤ç”¨æˆ·', async ({ page }) => {
    // Given - åˆ›å»ºä¸€ä¸ªç”¨äºåˆ é™¤çš„ç”¨æˆ·
    await dashboardPage.navigateToUserManagement();
    await userManagementPage.createTestUser({
      name: 'å¾…åˆ é™¤ç”¨æˆ·',
      email: 'delete@test.com',
      password: 'Password123!'
    });

    // When - åˆ é™¤ç”¨æˆ·
    await userManagementPage.deleteUser('å¾…åˆ é™¤ç”¨æˆ·');

    // ç¡®è®¤åˆ é™¤å¯¹è¯æ¡†
    await page.getByRole('button', { name: 'ç¡®è®¤åˆ é™¤' }).click();

    // Then - éªŒè¯åˆ é™¤æˆåŠŸ
    await expect(page.getByText('ç”¨æˆ·åˆ é™¤æˆåŠŸ')).toBeVisible();
    await expect(page.getByText('å¾…åˆ é™¤ç”¨æˆ·')).not.toBeVisible();
  });

  test('åº”è¯¥å¤„ç†ç”¨æˆ·åˆ›å»ºæ—¶çš„éªŒè¯é”™è¯¯', async ({ page }) => {
    // Given
    await dashboardPage.navigateToUserManagement();

    // When - å°è¯•åˆ›å»ºæ— æ•ˆç”¨æˆ·
    await userManagementPage.clickCreateUser();
    await userManagementPage.fillUserForm({
      name: '',  // ç©ºåç§°
      email: 'invalid-email',  // æ— æ•ˆé‚®ç®±
      password: '123',  // å¯†ç å¤ªçŸ­
      role: 'user'
    });
    await userManagementPage.submitUserForm();

    // Then - éªŒè¯æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
    await expect(page.getByText('ç”¨æˆ·åä¸èƒ½ä¸ºç©º')).toBeVisible();
    await expect(page.getByText('è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€')).toBeVisible();
    await expect(page.getByText('å¯†ç é•¿åº¦è‡³å°‘8ä¸ªå­—ç¬¦')).toBeVisible();
  });
});
```

## ğŸ“Š æ€§èƒ½æµ‹è¯•è§„èŒƒ

### æ€§èƒ½æµ‹è¯•è¦æ±‚
```typescript
// âœ… æ€§èƒ½æµ‹è¯•ç¤ºä¾‹
import { test, expect } from '@playwright/test';
import { performance } from 'perf_hooks';

test.describe('æ€§èƒ½æµ‹è¯•', () => {
  test('é¡µé¢åŠ è½½æ€§èƒ½', async ({ page }) => {
    // When
    const startTime = performance.now();
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    const endTime = performance.now();

    // Then
    const loadTime = endTime - startTime;
    expect(loadTime).toBeLessThan(2000); // é¡µé¢åŠ è½½æ—¶é—´åº”å°äº2ç§’
  });

  test('APIå“åº”æ€§èƒ½', async ({ request }) => {
    // When
    const startTime = performance.now();
    const response = await request.get('/api/users');
    const endTime = performance.now();

    // Then
    const responseTime = endTime - startTime;
    expect(response.status()).toBe(200);
    expect(responseTime).toBeLessThan(200); // APIå“åº”æ—¶é—´åº”å°äº200ms
  });
});
```

## âš ï¸ æµ‹è¯•è´¨é‡è¦æ±‚

### ç¦æ­¢äº‹é¡¹
- âŒ åœ¨æµ‹è¯•ä¸­ä½¿ç”¨çœŸå®ç”Ÿäº§æ•°æ®
- âŒ æµ‹è¯•ä»£ç ä¸­åŒ…å«ç¡¬ç¼–ç çš„æ•æ„Ÿä¿¡æ¯
- âŒ ç¼–å†™æ²¡æœ‰æ–­è¨€çš„æµ‹è¯•ç”¨ä¾‹
- âŒ æµ‹è¯•ç”¨ä¾‹ä¹‹é—´ç›¸äº’ä¾èµ–
- âŒ ä½¿ç”¨ `console.log` è¿›è¡Œè°ƒè¯•

### æœ€ä½³å®è·µ
- âœ… ä½¿ç”¨æè¿°æ€§çš„æµ‹è¯•ç”¨ä¾‹åç§°
- âœ… éµå¾ª AAA æ¨¡å¼ï¼ˆArrangeã€Actã€Assertï¼‰
- âœ… é€‚å½“ä½¿ç”¨ Mock å’Œ Stub
- âœ… æµ‹è¯•è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µ
- âœ… ä¿æŒæµ‹è¯•çš„ç‹¬ç«‹æ€§å’Œå¹‚ç­‰æ€§

---

**å‚è€ƒæ–‡æ¡£**:
- [æµ‹è¯•æ ‡å‡†æ–‡æ¡£](mdc:docs/testing-standard.md)
- [æµ‹è¯•æ•°æ®ç®¡ç†](mdc:docs/testing-data-management.md)
# ZK-Agent æµ‹è¯•è§„èŒƒä¸è´¨é‡ä¿è¯æ ‡å‡†

## ğŸ“‹ æµ‹è¯•æ¡†æ¶ç»Ÿä¸€æ ‡å‡†

åŸºäº [æµ‹è¯•æ ‡å‡†æ–‡æ¡£](mdc:docs/testing-standard.md)ï¼Œç¡®ä¿é¡¹ç›®æµ‹è¯•è´¨é‡å’Œè¦†ç›–ç‡ã€‚

### æµ‹è¯•æ¡†æ¶é€‰æ‹©
- **å‰ç«¯æµ‹è¯•**: ç»Ÿä¸€ä½¿ç”¨ Vitest ä½œä¸ºä¸»è¦æµ‹è¯•æ¡†æ¶
- **ç«¯åˆ°ç«¯æµ‹è¯•**: ä½¿ç”¨ Playwright è¿›è¡ŒE2Eæµ‹è¯•
- **åç«¯æµ‹è¯•**: ä½¿ç”¨ pytest è¿›è¡ŒPythonæµ‹è¯•
- **ç¦æ­¢**: å¼•å…¥å…¶ä»–æµ‹è¯•æ¡†æ¶ (å¦‚ Jestã€Mocha ç­‰)

### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚
```typescript
interface CoverageRequirements {
  minimumCoverage: {
    unitTests: 80;        // å•å…ƒæµ‹è¯•æœ€ä½è¦†ç›–ç‡
    integrationTests: 60; // é›†æˆæµ‹è¯•æœ€ä½è¦†ç›–ç‡
    criticalPaths: 90;    // å…³é”®ä¸šåŠ¡è·¯å¾„è¦†ç›–ç‡
    e2eTests: 50;         // ç«¯åˆ°ç«¯æµ‹è¯•è¦†ç›–ç‡
  };

  qualityGates: {
    codeQuality: 90;      // ä»£ç è´¨é‡è¯„åˆ†
    testReliability: 95;  // æµ‹è¯•å¯é æ€§
    performanceRegression: 5; // æ€§èƒ½å›å½’é˜ˆå€¼(%)
  };
}
```

## ğŸ§ª å•å…ƒæµ‹è¯•è§„èŒƒ

### Vitestå•å…ƒæµ‹è¯•æ ‡å‡†
```typescript
// âœ… æ­£ç¡®çš„Vitestæµ‹è¯•ç»“æ„
import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest';
import { TestUtils, withTestEnvironment } from '@/lib/testing/test-utils';
import { UserService } from '@/lib/services/user-service';
import type { UserProfile, CreateUserRequest } from '@/types/user';

describe('UserService', () => {
  let userService: UserService;
  let mockDatabase: any;

  beforeAll(async () => {
    // åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
    TestUtils.initialize();
    mockDatabase = TestUtils.createMockDatabase();
    userService = new UserService(mockDatabase);
  });

  afterAll(async () => {
    // æ¸…ç†æµ‹è¯•ç¯å¢ƒ
    await TestUtils.cleanup();
  });

  describe('createUser', () => {
    it('åº”è¯¥æˆåŠŸåˆ›å»ºç”¨æˆ·å¹¶è¿”å›ç”¨æˆ·ä¿¡æ¯', async () => {
      // Given - å‡†å¤‡æµ‹è¯•æ•°æ®
      const createRequest: CreateUserRequest = {
        name: 'å¼ ä¸‰',
        email: 'zhangsan@example.com',
        password: 'securePassword123'
      };

      const expectedUser: UserProfile = {
        id: 'user-123',
        name: 'å¼ ä¸‰',
        email: 'zhangsan@example.com',
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // æ¨¡æ‹Ÿæ•°æ®åº“è¡Œä¸º
      mockDatabase.users.create.mockResolvedValue(expectedUser);

      // When - æ‰§è¡Œæµ‹è¯•
      const result = await userService.createUser(createRequest);

      // Then - éªŒè¯ç»“æœ
      expect(result.success).toBe(true);
      expect(result.data).toEqual(expectedUser);
      expect(result.data.email).toBe(createRequest.email);
      expect(mockDatabase.users.create).toHaveBeenCalledWith({
        name: createRequest.name,
        email: createRequest.email,
        passwordHash: expect.any(String)
      });
    });

    it('åº”è¯¥å¤„ç†é‚®ç®±å·²å­˜åœ¨çš„é”™è¯¯æƒ…å†µ', async () => {
      // Given
      const duplicateRequest: CreateUserRequest = {
        name: 'æå››',
        email: 'duplicate@example.com',
        password: 'password123'
      };

      mockDatabase.users.create.mockRejectedValue(
        new Error('Email already exists')
      );

      // When & Then
      const result = await userService.createUser(duplicateRequest);

      expect(result.success).toBe(false);
      expect(result.error).toContain('é‚®ç®±å·²å­˜åœ¨');
    });

    it('åº”è¯¥éªŒè¯è¾“å…¥å‚æ•°å¹¶æ‹’ç»æ— æ•ˆæ•°æ®', async () => {
      // Given - æ— æ•ˆçš„ç”¨æˆ·æ•°æ®
      const invalidRequest = {
        name: '',
        email: 'invalid-email',
        password: '123' // å¯†ç å¤ªçŸ­
      } as CreateUserRequest;

      // When & Then
      await expect(userService.createUser(invalidRequest))
        .rejects.toThrow('Invalid user data');
    });
  });

  describe('getUserById', () => {
    it('åº”è¯¥è¿”å›å­˜åœ¨çš„ç”¨æˆ·ä¿¡æ¯', withTestEnvironment(async () => {
      // Given
      const userId = 'user-123';
      const expectedUser: UserProfile = {
        id: userId,
        name: 'å¼ ä¸‰',
        email: 'zhangsan@example.com',
        createdAt: new Date(),
        updatedAt: new Date()
      };

      mockDatabase.users.findById.mockResolvedValue(expectedUser);

      // When
      const result = await userService.getUserById(userId);

      // Then
      expect(result).toEqual(expectedUser);
      expect(mockDatabase.users.findById).toHaveBeenCalledWith(userId);
    }));

    it('åº”è¯¥åœ¨ç”¨æˆ·ä¸å­˜åœ¨æ—¶è¿”å›null', async () => {
      // Given
      const nonExistentUserId = 'non-existent';
      mockDatabase.users.findById.mockResolvedValue(null);

      // When
      const result = await userService.getUserById(nonExistentUserId);

      // Then
      expect(result).toBeNull();
    });
  });
});
```

### Pythonå•å…ƒæµ‹è¯•æ ‡å‡†
```python
# âœ… æ­£ç¡®çš„pytestæµ‹è¯•ç»“æ„
import pytest
import asyncio
from unittest.mock import Mock, patch, AsyncMock
from typing import Dict, Any, List

from app.services.ai_service import AIService
from app.models.agent import Agent, AgentConfig
from app.exceptions import AIServiceError, ValidationError
from tests.fixtures import sample_agent_config, mock_llm_client


class TestAIService:
    """AIæœåŠ¡æµ‹è¯•ç±»

    æµ‹è¯•AIæœåŠ¡çš„æ ¸å¿ƒåŠŸèƒ½ï¼ŒåŒ…æ‹¬æ™ºèƒ½ä½“åˆ›å»ºã€å¯¹è¯å¤„ç†ã€é”™è¯¯å¤„ç†ç­‰ã€‚
    """

    @pytest.fixture
    def ai_service(self) -> AIService:
        """åˆ›å»ºAIæœåŠ¡å®ä¾‹"""
        return AIService()

    @pytest.fixture
    def mock_agent(self) -> Agent:
        """åˆ›å»ºæ¨¡æ‹Ÿæ™ºèƒ½ä½“"""
        return Agent(
            id="agent-123",
            name="æµ‹è¯•æ™ºèƒ½ä½“",
            config=AgentConfig(
                model="gpt-4",
                temperature=0.7,
                max_tokens=2000
            )
        )

    @pytest.mark.asyncio
    async def test_create_agent_success(
        self,
        ai_service: AIService,
        sample_agent_config: AgentConfig
    ):
        """æµ‹è¯•æˆåŠŸåˆ›å»ºæ™ºèƒ½ä½“"""
        # Given
        with patch.object(ai_service.db, 'save_agent') as mock_save:
            mock_save.return_value = "agent-123"

            # When
            result = await ai_service.create_agent(sample_agent_config)

            # Then
            assert result.success is True
            assert result.agent_id == "agent-123"
            assert result.agent.name == sample_agent_config.name
            mock_save.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_agent_validation_error(self, ai_service: AIService):
        """æµ‹è¯•æ™ºèƒ½ä½“åˆ›å»ºæ—¶çš„éªŒè¯é”™è¯¯"""
        # Given - æ— æ•ˆé…ç½®
        invalid_config = AgentConfig(
            name="",  # ç©ºåç§°
            model="invalid-model",  # æ— æ•ˆæ¨¡å‹
            temperature=-1.0  # æ— æ•ˆæ¸©åº¦
        )

        # When & Then
        with pytest.raises(ValidationError) as exc_info:
            await ai_service.create_agent(invalid_config)

        assert "åç§°ä¸èƒ½ä¸ºç©º" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_chat_with_agent_success(
        self,
        ai_service: AIService,
        mock_agent: Agent,
        mock_llm_client: AsyncMock
    ):
        """æµ‹è¯•ä¸æ™ºèƒ½ä½“æˆåŠŸå¯¹è¯"""
        # Given
        message = "ä½ å¥½ï¼Œè¯·ä»‹ç»ä¸€ä¸‹è‡ªå·±"
        expected_response = "ä½ å¥½ï¼æˆ‘æ˜¯ä¸€ä¸ªAIåŠ©æ‰‹ï¼Œå¯ä»¥å¸®åŠ©æ‚¨è§£å†³å„ç§é—®é¢˜ã€‚"

        mock_llm_client.chat_completion.return_value = {
            "choices": [{"message": {"content": expected_response}}]
        }

        with patch.object(ai_service, 'llm_client', mock_llm_client):
            # When
            response = await ai_service.chat_with_agent(
                agent_id=mock_agent.id,
                message=message,
                session_id="session-123"
            )

            # Then
            assert response.success is True
            assert response.content == expected_response
            assert response.session_id == "session-123"
            mock_llm_client.chat_completion.assert_called_once()

    @pytest.mark.asyncio
    async def test_chat_with_nonexistent_agent(self, ai_service: AIService):
        """æµ‹è¯•ä¸ä¸å­˜åœ¨çš„æ™ºèƒ½ä½“å¯¹è¯"""
        # Given
        nonexistent_agent_id = "nonexistent-agent"

        with patch.object(ai_service.db, 'get_agent') as mock_get:
            mock_get.return_value = None

            # When & Then
            with pytest.raises(AIServiceError) as exc_info:
                await ai_service.chat_with_agent(
                    agent_id=nonexistent_agent_id,
                    message="æµ‹è¯•æ¶ˆæ¯",
                    session_id="session-123"
                )

            assert "æ™ºèƒ½ä½“ä¸å­˜åœ¨" in str(exc_info.value)

    @pytest.mark.parametrize("temperature,expected_valid", [
        (0.0, True),
        (0.5, True),
        (1.0, True),
        (-0.1, False),
        (1.1, False),
        (2.0, False)
    ])
    def test_validate_temperature(
        self,
        ai_service: AIService,
        temperature: float,
        expected_valid: bool
    ):
        """æµ‹è¯•æ¸©åº¦å‚æ•°éªŒè¯"""
        # When
        is_valid = ai_service._validate_temperature(temperature)

        # Then
        assert is_valid == expected_valid

    @pytest.mark.performance
    async def test_concurrent_chat_performance(
        self,
        ai_service: AIService,
        mock_agent: Agent
    ):
        """æµ‹è¯•å¹¶å‘å¯¹è¯æ€§èƒ½"""
        # Given
        concurrent_count = 50
        message = "æ€§èƒ½æµ‹è¯•æ¶ˆæ¯"

        with patch.object(ai_service, 'chat_with_agent') as mock_chat:
            mock_chat.return_value = AsyncMock(
                success=True,
                content="å“åº”æ¶ˆæ¯",
                latency=0.1
            )

            # When
            start_time = asyncio.get_event_loop().time()
            tasks = [
                ai_service.chat_with_agent(
                    agent_id=mock_agent.id,
                    message=f"{message}-{i}",
                    session_id=f"session-{i}"
                )
                for i in range(concurrent_count)
            ]

            results = await asyncio.gather(*tasks)
            end_time = asyncio.get_event_loop().time()

            # Then
            assert len(results) == concurrent_count
            assert all(result.success for result in results)

            total_time = end_time - start_time
            assert total_time < 5.0  # 50ä¸ªå¹¶å‘è¯·æ±‚åº”åœ¨5ç§’å†…å®Œæˆ
```

## ğŸ”— é›†æˆæµ‹è¯•è§„èŒƒ

### APIé›†æˆæµ‹è¯•æ ‡å‡†
```typescript
// âœ… APIé›†æˆæµ‹è¯•ç¤ºä¾‹
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { IntegrationTestUtils } from '@/lib/testing/integration-utils';
import { TestServer } from '@/lib/testing/test-server';
import { ApiClient } from '@/lib/api/api-client';

describe('ç”¨æˆ·ç®¡ç† API é›†æˆæµ‹è¯•', () => {
  let testServer: TestServer;
  let apiClient: ApiClient;
  let testUtils: IntegrationTestUtils;

  beforeAll(async () => {
    // å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨
    testServer = new TestServer();
    await testServer.start();

    // åˆå§‹åŒ–æµ‹è¯•å·¥å…·
    testUtils = new IntegrationTestUtils();
    await testUtils.setupTestDatabase();

    // åˆ›å»ºAPIå®¢æˆ·ç«¯
    apiClient = new ApiClient({
      baseUrl: testServer.getBaseUrl(),
      timeout: 5000
    });
  });

  afterAll(async () => {
    await testUtils.cleanupTestDatabase();
    await testServer.stop();
  });

  describe('POST /api/users', () => {
    it('åº”è¯¥æˆåŠŸåˆ›å»ºç”¨æˆ·å¹¶è¿”å›ç”¨æˆ·ä¿¡æ¯', async () => {
      // Given
      const userData = {
        name: 'é›†æˆæµ‹è¯•ç”¨æˆ·',
        email: 'integration@test.com',
        password: 'SecurePassword123!'
      };

      // When
      const response = await apiClient.post('/api/users', userData);

      // Then
      expect(response.status).toBe(201);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toMatchObject({
        name: userData.name,
        email: userData.email,
        id: expect.any(String),
        createdAt: expect.any(String)
      });
      expect(response.data.data).not.toHaveProperty('password');
    });

    it('åº”è¯¥æ‹’ç»é‡å¤çš„é‚®ç®±åœ°å€', async () => {
      // Given - å…ˆåˆ›å»ºä¸€ä¸ªç”¨æˆ·
      const userData = {
        name: 'ç”¨æˆ·1',
        email: 'duplicate@test.com',
        password: 'Password123!'
      };

      await apiClient.post('/api/users', userData);

      // When - å°è¯•åˆ›å»ºç›¸åŒé‚®ç®±çš„ç”¨æˆ·
      const duplicateData = {
        ...userData,
        name: 'ç”¨æˆ·2'
      };

      // Then
      await expect(apiClient.post('/api/users', duplicateData))
        .rejects.toMatchObject({
          response: {
            status: 409,
            data: {
              success: false,
              error: expect.stringContaining('é‚®ç®±å·²å­˜åœ¨')
            }
          }
        });
    });
  });

  describe('GET /api/users/:id', () => {
    it('åº”è¯¥è¿”å›å­˜åœ¨çš„ç”¨æˆ·ä¿¡æ¯', async () => {
      // Given - å…ˆåˆ›å»ºä¸€ä¸ªç”¨æˆ·
      const createResponse = await apiClient.post('/api/users', {
        name: 'æŸ¥è¯¢æµ‹è¯•ç”¨æˆ·',
        email: 'query@test.com',
        password: 'Password123!'
      });

      const userId = createResponse.data.data.id;

      // When
      const response = await apiClient.get(`/api/users/${userId}`);

      // Then
      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toMatchObject({
        id: userId,
        name: 'æŸ¥è¯¢æµ‹è¯•ç”¨æˆ·',
        email: 'query@test.com'
      });
    });

    it('åº”è¯¥åœ¨ç”¨æˆ·ä¸å­˜åœ¨æ—¶è¿”å›404', async () => {
      // Given
      const nonExistentId = 'non-existent-user-id';

      // When & Then
      await expect(apiClient.get(`/api/users/${nonExistentId}`))
        .rejects.toMatchObject({
          response: {
            status: 404,
            data: {
              success: false,
              error: expect.stringContaining('ç”¨æˆ·ä¸å­˜åœ¨')
            }
          }
        });
    });
  });
});
```

## ğŸ­ ç«¯åˆ°ç«¯æµ‹è¯•è§„èŒƒ

### Playwright E2Eæµ‹è¯•æ ‡å‡†
```typescript
// âœ… Playwrightç«¯åˆ°ç«¯æµ‹è¯•ç¤ºä¾‹
import { test, expect } from '@playwright/test';
import { LoginPage } from '@/e2e/pages/login-page';
import { DashboardPage } from '@/e2e/pages/dashboard-page';
import { UserManagementPage } from '@/e2e/pages/user-management-page';

test.describe('ç”¨æˆ·ç®¡ç†ç«¯åˆ°ç«¯æµ‹è¯•', () => {
  let loginPage: LoginPage;
  let dashboardPage: DashboardPage;
  let userManagementPage: UserManagementPage;

  test.beforeEach(async ({ page }) => {
    loginPage = new LoginPage(page);
    dashboardPage = new DashboardPage(page);
    userManagementPage = new UserManagementPage(page);

    // ç™»å½•åˆ°ç³»ç»Ÿ
    await loginPage.goto();
    await loginPage.login('admin@test.com', 'AdminPassword123!');
    await expect(page).toHaveTitle('ZK-Agent Dashboard');
  });

  test('åº”è¯¥èƒ½å¤Ÿåˆ›å»ºæ–°ç”¨æˆ·', async ({ page }) => {
    // Given - å¯¼èˆªåˆ°ç”¨æˆ·ç®¡ç†é¡µé¢
    await dashboardPage.navigateToUserManagement();
    await expect(page.getByRole('heading', { name: 'ç”¨æˆ·ç®¡ç†' })).toBeVisible();

    // When - åˆ›å»ºæ–°ç”¨æˆ·
    await userManagementPage.clickCreateUser();
    await userManagementPage.fillUserForm({
      name: 'E2Eæµ‹è¯•ç”¨æˆ·',
      email: 'e2e@test.com',
      password: 'E2EPassword123!',
      role: 'user'
    });
    await userManagementPage.submitUserForm();

    // Then - éªŒè¯ç”¨æˆ·åˆ›å»ºæˆåŠŸ
    await expect(page.getByText('ç”¨æˆ·åˆ›å»ºæˆåŠŸ')).toBeVisible();
    await expect(page.getByText('E2Eæµ‹è¯•ç”¨æˆ·')).toBeVisible();
    await expect(page.getByText('e2e@test.com')).toBeVisible();
  });

  test('åº”è¯¥èƒ½å¤Ÿç¼–è¾‘ç”¨æˆ·ä¿¡æ¯', async ({ page }) => {
    // Given - ç¡®ä¿æœ‰ç”¨æˆ·å­˜åœ¨
    await dashboardPage.navigateToUserManagement();

    // å¦‚æœæ²¡æœ‰ç”¨æˆ·ï¼Œå…ˆåˆ›å»ºä¸€ä¸ª
    const userCount = await page.locator('[data-testid="user-row"]').count();
    if (userCount === 0) {
      await userManagementPage.createTestUser({
        name: 'å¾…ç¼–è¾‘ç”¨æˆ·',
        email: 'edit@test.com',
        password: 'Password123!'
      });
    }

    // When - ç¼–è¾‘ç”¨æˆ·
    await userManagementPage.editFirstUser();
    await userManagementPage.updateUserName('å·²ç¼–è¾‘çš„ç”¨æˆ·å');
    await userManagementPage.submitUserForm();

    // Then - éªŒè¯ç¼–è¾‘æˆåŠŸ
    await expect(page.getByText('ç”¨æˆ·ä¿¡æ¯æ›´æ–°æˆåŠŸ')).toBeVisible();
    await expect(page.getByText('å·²ç¼–è¾‘çš„ç”¨æˆ·å')).toBeVisible();
  });

  test('åº”è¯¥èƒ½å¤Ÿåˆ é™¤ç”¨æˆ·', async ({ page }) => {
    // Given - åˆ›å»ºä¸€ä¸ªç”¨äºåˆ é™¤çš„ç”¨æˆ·
    await dashboardPage.navigateToUserManagement();
    await userManagementPage.createTestUser({
      name: 'å¾…åˆ é™¤ç”¨æˆ·',
      email: 'delete@test.com',
      password: 'Password123!'
    });

    // When - åˆ é™¤ç”¨æˆ·
    await userManagementPage.deleteUser('å¾…åˆ é™¤ç”¨æˆ·');

    // ç¡®è®¤åˆ é™¤å¯¹è¯æ¡†
    await page.getByRole('button', { name: 'ç¡®è®¤åˆ é™¤' }).click();

    // Then - éªŒè¯åˆ é™¤æˆåŠŸ
    await expect(page.getByText('ç”¨æˆ·åˆ é™¤æˆåŠŸ')).toBeVisible();
    await expect(page.getByText('å¾…åˆ é™¤ç”¨æˆ·')).not.toBeVisible();
  });

  test('åº”è¯¥å¤„ç†ç”¨æˆ·åˆ›å»ºæ—¶çš„éªŒè¯é”™è¯¯', async ({ page }) => {
    // Given
    await dashboardPage.navigateToUserManagement();

    // When - å°è¯•åˆ›å»ºæ— æ•ˆç”¨æˆ·
    await userManagementPage.clickCreateUser();
    await userManagementPage.fillUserForm({
      name: '',  // ç©ºåç§°
      email: 'invalid-email',  // æ— æ•ˆé‚®ç®±
      password: '123',  // å¯†ç å¤ªçŸ­
      role: 'user'
    });
    await userManagementPage.submitUserForm();

    // Then - éªŒè¯æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
    await expect(page.getByText('ç”¨æˆ·åä¸èƒ½ä¸ºç©º')).toBeVisible();
    await expect(page.getByText('è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€')).toBeVisible();
    await expect(page.getByText('å¯†ç é•¿åº¦è‡³å°‘8ä¸ªå­—ç¬¦')).toBeVisible();
  });
});
```

## ğŸ“Š æ€§èƒ½æµ‹è¯•è§„èŒƒ

### æ€§èƒ½æµ‹è¯•è¦æ±‚
```typescript
// âœ… æ€§èƒ½æµ‹è¯•ç¤ºä¾‹
import { test, expect } from '@playwright/test';
import { performance } from 'perf_hooks';

test.describe('æ€§èƒ½æµ‹è¯•', () => {
  test('é¡µé¢åŠ è½½æ€§èƒ½', async ({ page }) => {
    // When
    const startTime = performance.now();
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    const endTime = performance.now();

    // Then
    const loadTime = endTime - startTime;
    expect(loadTime).toBeLessThan(2000); // é¡µé¢åŠ è½½æ—¶é—´åº”å°äº2ç§’
  });

  test('APIå“åº”æ€§èƒ½', async ({ request }) => {
    // When
    const startTime = performance.now();
    const response = await request.get('/api/users');
    const endTime = performance.now();

    // Then
    const responseTime = endTime - startTime;
    expect(response.status()).toBe(200);
    expect(responseTime).toBeLessThan(200); // APIå“åº”æ—¶é—´åº”å°äº200ms
  });
});
```

## âš ï¸ æµ‹è¯•è´¨é‡è¦æ±‚

### ç¦æ­¢äº‹é¡¹
- âŒ åœ¨æµ‹è¯•ä¸­ä½¿ç”¨çœŸå®ç”Ÿäº§æ•°æ®
- âŒ æµ‹è¯•ä»£ç ä¸­åŒ…å«ç¡¬ç¼–ç çš„æ•æ„Ÿä¿¡æ¯
- âŒ ç¼–å†™æ²¡æœ‰æ–­è¨€çš„æµ‹è¯•ç”¨ä¾‹
- âŒ æµ‹è¯•ç”¨ä¾‹ä¹‹é—´ç›¸äº’ä¾èµ–
- âŒ ä½¿ç”¨ `console.log` è¿›è¡Œè°ƒè¯•

### æœ€ä½³å®è·µ
- âœ… ä½¿ç”¨æè¿°æ€§çš„æµ‹è¯•ç”¨ä¾‹åç§°
- âœ… éµå¾ª AAA æ¨¡å¼ï¼ˆArrangeã€Actã€Assertï¼‰
- âœ… é€‚å½“ä½¿ç”¨ Mock å’Œ Stub
- âœ… æµ‹è¯•è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µ
- âœ… ä¿æŒæµ‹è¯•çš„ç‹¬ç«‹æ€§å’Œå¹‚ç­‰æ€§

---

**å‚è€ƒæ–‡æ¡£**:
- [æµ‹è¯•æ ‡å‡†æ–‡æ¡£](mdc:docs/testing-standard.md)
- [æµ‹è¯•æ•°æ®ç®¡ç†](mdc:docs/testing-data-management.md)
