---
alwaysApply: true
---
# ZK-Agent APIåº“æ¶æ„è§„èŒƒ

## ğŸ“‹ å®¢æˆ·ç«¯æ¶æ„é‡æ„ï¼ˆ2025-01-23ï¼‰

åŸºäº [APIåº“æ¶æ„è¯´æ˜](mdc:lib/api/README.md) å’Œ [APIè®¾è®¡æ ‡å‡†](.cursor/rules/06-api-design-standards.mdc)ï¼Œç¡®ä¿APIå®¢æˆ·ç«¯çš„ç»Ÿä¸€æ€§å’Œåè„†å¼±æ€§ã€‚

### ğŸ¯ ç»Ÿä¸€å®¢æˆ·ç«¯ç­–ç•¥

ç»è¿‡åè„†å¼±æ¨¡å¼åˆ†æï¼ŒåŸæœ‰7ä¸ªé‡å¤å®¢æˆ·ç«¯å·²æ•´åˆä¸º3å±‚æ¶æ„ï¼š

#### 1. åŸºç¡€å±‚ - `fastgpt-client.ts`
- **èŒè´£**: åŸºç¡€FastGPT APIè°ƒç”¨
- **ç‰¹æ€§**: ç®€å•ã€å¯é ã€æ— ä¾èµ–
- **ä½¿ç”¨åœºæ™¯**: ç›´æ¥APIè°ƒç”¨

#### 2. å¢å¼ºå±‚ - `enhanced-fastgpt-client.ts`
- **èŒè´£**: å¢åŠ ç¼“å­˜ã€é‡è¯•ã€äº‹ä»¶æœºåˆ¶
- **ç‰¹æ€§**: ç»§æ‰¿åŸºç¡€å®¢æˆ·ç«¯ï¼Œæ‰©å±•åŠŸèƒ½
- **ä½¿ç”¨åœºæ™¯**: ç”Ÿäº§ç¯å¢ƒã€é«˜å¯ç”¨éœ€æ±‚

#### 3. é€‚é…å±‚ - `fastgpt-ag-ui-adapter.ts`
- **èŒè´£**: AG-UIåè®®è½¬æ¢
- **ç‰¹æ€§**: äº‹ä»¶æµè½¬æ¢ã€åè®®é€‚é…
- **ä½¿ç”¨åœºæ™¯**: AG-UIå‰ç«¯é›†æˆ

### ğŸš« å·²æ¸…ç†çš„å†—ä½™æ–‡ä»¶
- ~~`fastgpt.ts`~~ - åŠŸèƒ½é‡å¤ï¼Œå·²åˆ é™¤
- ~~`enhanced-api-client.ts`~~ - æ³›ç”¨æ€§è¿‡å¼ºï¼Œä¿ç•™ä½†é™åˆ¶ä½¿ç”¨åœºæ™¯

### ğŸ“‹ ä½¿ç”¨æŒ‡å—

```typescript
// âœ… åŸºç¡€ä½¿ç”¨
import fastGPTClient from '@/lib/api/fastgpt-client';
const response = await fastGPTClient.chatCompletions(params);

// âœ… å¢å¼ºåŠŸèƒ½
import enhancedClient from '@/lib/api/enhanced-fastgpt-client';
enhancedClient.on('retry', (info) => console.log('é‡è¯•:', info));
const cached = await enhancedClient.chatCompletionsWithCache(params, 'key');

// âœ… AG-UIé›†æˆ
import { FastGptAgUiAdapter } from '@/lib/api/fastgpt-ag-ui-adapter';
const adapter = new FastGptAgUiAdapter(threadId, runId);
```

### ğŸ”¥ åè„†å¼±æ”¶ç›Š
- **å†—ä½™æ¶ˆé™¤**: 7â†’3ä¸ªå®¢æˆ·ç«¯ï¼Œç»´æŠ¤æˆæœ¬é™ä½70%
- **èŒè´£æ¸…æ™°**: æ¯å±‚å•ä¸€èŒè´£ï¼Œæ‰©å±•æ€§æå‡
- **åè®®ç»Ÿä¸€**: å¼ºåˆ¶AG-UIåè®®è½¬æ¢ï¼Œé¿å…å‰åç«¯ä¸åŒ¹é…

### ğŸš¨ ä½¿ç”¨çº¦æŸ
1. **ç¦æ­¢**ç›´æ¥ä½¿ç”¨`enhanced-api-client.ts`è¿›è¡ŒFastGPTè°ƒç”¨
2. **å¿…é¡»**é€šè¿‡é€‚é…å™¨å±‚è¿›è¡ŒAG-UIåè®®è½¬æ¢
3. **ä¼˜å…ˆ**ä½¿ç”¨å¢å¼ºå®¢æˆ·ç«¯è€ŒéåŸºç¡€å®¢æˆ·ç«¯

## ğŸ—ï¸ APIåº“æ¶æ„è¯¦ç»†è®¾è®¡

### åŸºç¡€APIå®¢æˆ·ç«¯æ¶æ„
```typescript
/**
 * åŸºç¡€FastGPTå®¢æˆ·ç«¯
 * éµå¾ªAPIè®¾è®¡æ ‡å‡†çš„ç»Ÿä¸€å“åº”æ ¼å¼
 */
interface FastGPTClientConfig {
  baseUrl: string;
  apiKey: string;
  timeout: number;
  retryCount: number;
}

class FastGPTClient {
  private config: FastGPTClientConfig;
  private httpClient: HttpClient;

  constructor(config: FastGPTClientConfig) {
    this.config = config;
    this.httpClient = new HttpClient({
      baseURL: config.baseUrl,
      timeout: config.timeout,
      headers: {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * èŠå¤©å®Œæˆæ¥å£
   * ç¬¦åˆOpenAIåè®®æ ‡å‡†
   */
  async chatCompletions(params: ChatCompletionParams): Promise<ChatCompletionResponse> {
    try {
      const response = await this.httpClient.post('/v1/chat/completions', params);
      return this.handleResponse(response);
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * æµå¼èŠå¤©å®Œæˆ
   * æ”¯æŒServer-Sent Events
   */
  async chatCompletionsStream(params: ChatCompletionParams): Promise<AsyncIterable<ChatCompletionChunk>> {
    const response = await this.httpClient.post('/v1/chat/completions', {
      ...params,
      stream: true
    }, {
      responseType: 'stream'
    });

    return this.parseStreamResponse(response);
  }

  private handleResponse<T>(response: HttpResponse): T {
    if (response.status >= 200 && response.status < 300) {
      return response.data;
    }
    throw new ApiError(response.status, response.statusText, response.data);
  }

  private handleError(error: any): ApiError {
    if (error.response) {
      return new ApiError(error.response.status, error.response.statusText, error.response.data);
    }
    return new ApiError(500, 'Internal Server Error', error.message);
  }
}
```

### å¢å¼ºAPIå®¢æˆ·ç«¯æ¶æ„
```typescript
/**
 * å¢å¼ºFastGPTå®¢æˆ·ç«¯
 * æ·»åŠ ç¼“å­˜ã€é‡è¯•ã€äº‹ä»¶æœºåˆ¶
 */
class EnhancedFastGPTClient extends FastGPTClient {
  private cache: CacheManager;
  private eventEmitter: EventEmitter;
  private metrics: MetricsCollector;

  constructor(config: FastGPTClientConfig) {
    super(config);
    this.cache = new CacheManager();
    this.eventEmitter = new EventEmitter();
    this.metrics = new MetricsCollector();
  }

  /**
   * å¸¦ç¼“å­˜çš„èŠå¤©å®Œæˆ
   */
  async chatCompletionsWithCache(
    params: ChatCompletionParams,
    cacheKey?: string
  ): Promise<ChatCompletionResponse> {
    const key = cacheKey || this.generateCacheKey(params);

    // å°è¯•ä»ç¼“å­˜è·å–
    const cached = await this.cache.get(key);
    if (cached) {
      this.metrics.recordCacheHit();
      return cached;
    }

    // è°ƒç”¨APIå¹¶ç¼“å­˜ç»“æœ
    const response = await this.chatCompletionsWithRetry(params);
    await this.cache.set(key, response, 3600); // ç¼“å­˜1å°æ—¶
    this.metrics.recordCacheMiss();

    return response;
  }

  /**
   * å¸¦é‡è¯•çš„èŠå¤©å®Œæˆ
   */
  async chatCompletionsWithRetry(params: ChatCompletionParams): Promise<ChatCompletionResponse> {
    let lastError: Error;

    for (let attempt = 1; attempt <= this.config.retryCount; attempt++) {
      try {
        const response = await super.chatCompletions(params);
        this.metrics.recordSuccess(attempt);
        return response;
      } catch (error) {
        lastError = error as Error;

        if (attempt < this.config.retryCount && this.isRetryableError(error)) {
          const delay = this.calculateRetryDelay(attempt);
          this.eventEmitter.emit('retry', { attempt, delay, error });
          await this.sleep(delay);
        } else {
          this.metrics.recordFailure(attempt);
          break;
        }
      }
    }

    throw lastError!;
  }

  /**
   * å¥åº·æ£€æŸ¥
   */
  async healthCheck(): Promise<HealthStatus> {
    try {
      const start = Date.now();
      await this.chatCompletions({
        messages: [{ role: 'user', content: 'health check' }],
        max_tokens: 1
      });
      const responseTime = Date.now() - start;

      return {
        status: 'healthy',
        responseTime,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  // äº‹ä»¶ç›‘å¬å™¨
  on(event: string, listener: Function): void {
    this.eventEmitter.on(event, listener);
  }

  off(event: string, listener: Function): void {
    this.eventEmitter.off(event, listener);
  }

  private isRetryableError(error: any): boolean {
    const retryableStatusCodes = [408, 429, 500, 502, 503, 504];
    return retryableStatusCodes.includes(error.status);
  }

  private calculateRetryDelay(attempt: number): number {
    // æŒ‡æ•°é€€é¿ç®—æ³•
    return Math.min(1000 * Math.pow(2, attempt - 1), 30000);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private generateCacheKey(params: ChatCompletionParams): string {
    const sortedParams = JSON.stringify(params, Object.keys(params).sort());
    return `fastgpt:${this.hashString(sortedParams)}`;
  }

  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return hash.toString(16);
  }
}
```

### AG-UIé€‚é…å™¨æ¶æ„
```typescript
/**
 * FastGPT AG-UIé€‚é…å™¨
 * å°†FastGPT APIå“åº”è½¬æ¢ä¸ºAG-UIåè®®æ ¼å¼
 */
class FastGptAgUiAdapter {
  private client: EnhancedFastGPTClient;
  private threadId: string;
  private runId: string;

  constructor(threadId: string, runId: string) {
    this.client = new EnhancedFastGPTClient(config);
    this.threadId = threadId;
    this.runId = runId;
  }

  /**
   * è½¬æ¢ä¸ºAG-UIæ¶ˆæ¯æ ¼å¼
   */
  async processMessage(message: string): Promise<AgUiMessage> {
    try {
      const response = await this.client.chatCompletions({
        messages: [{ role: 'user', content: message }],
        stream: false
      });

      return {
        id: generateMessageId(),
        role: 'assistant',
        content: response.choices[0]?.message?.content || '',
        threadId: this.threadId,
        runId: this.runId,
        timestamp: new Date().toISOString(),
        metadata: {
          model: response.model,
          usage: response.usage,
          finishReason: response.choices[0]?.finish_reason
        }
      };
    } catch (error) {
      throw new AgUiError('Failed to process message', error);
    }
  }

  /**
   * æµå¼æ¶ˆæ¯å¤„ç†
   */
  async *processMessageStream(message: string): AsyncGenerator<AgUiStreamChunk> {
    try {
      const stream = await this.client.chatCompletionsStream({
        messages: [{ role: 'user', content: message }],
        stream: true
      });

      let content = '';
      for await (const chunk of stream) {
        const delta = chunk.choices[0]?.delta?.content || '';
        content += delta;

        yield {
          id: generateChunkId(),
          type: 'text',
          content: delta,
          threadId: this.threadId,
          runId: this.runId,
          timestamp: new Date().toISOString()
        };
      }

      // å‘é€ç»“æŸæ ‡å¿—
      yield {
        id: generateChunkId(),
        type: 'done',
        content: '',
        threadId: this.threadId,
        runId: this.runId,
        timestamp: new Date().toISOString(),
        metadata: {
          totalContent: content,
          contentLength: content.length
        }
      };
    } catch (error) {
      yield {
        id: generateChunkId(),
        type: 'error',
        content: error.message,
        threadId: this.threadId,
        runId: this.runId,
        timestamp: new Date().toISOString()
      };
    }
  }
}
```

## ğŸ”§ è·¯ç”±å·¥å‚æ¨¡å¼

### APIè·¯ç”±ç»Ÿä¸€ç®¡ç†
```typescript
/**
 * APIè·¯ç”±å·¥å‚
 * ç»Ÿä¸€ç®¡ç†æ‰€æœ‰APIè·¯ç”±çš„åˆ›å»ºå’Œé…ç½®
 */
class ApiRouteFactory {
  private clients: Map<string, any> = new Map();

  /**
   * åˆ›å»ºFastGPTè·¯ç”±
   */
  createFastGPTRoute(config: FastGPTConfig): FastGPTRoute {
    const clientKey = `fastgpt:${config.appId}`;

    if (!this.clients.has(clientKey)) {
      const client = new EnhancedFastGPTClient(config);
      this.clients.set(clientKey, client);
    }

    return new FastGPTRoute(this.clients.get(clientKey)!);
  }

  /**
   * åˆ›å»ºæ ‡å‡†APIè·¯ç”±
   */
  createStandardRoute(config: StandardApiConfig): StandardRoute {
    return new StandardRoute(config);
  }

  /**
   * è·å–å¥åº·æ£€æŸ¥è·¯ç”±
   */
  getHealthCheckRoute(): HealthCheckRoute {
    return new HealthCheckRoute(this.clients);
  }
}

/**
 * FastGPTè·¯ç”±å®ç°
 */
class FastGPTRoute {
  private client: EnhancedFastGPTClient;

  constructor(client: EnhancedFastGPTClient) {
    this.client = client;
  }

  async chat(request: NextRequest): Promise<NextResponse> {
    try {
      const body = await request.json();
      const response = await this.client.chatCompletions(body);

      return NextResponse.json(createSuccessResponse(response));
    } catch (error) {
      return NextResponse.json(
        createErrorResponse(ApiErrorCode.INTERNAL_ERROR, error.message),
        { status: 500 }
      );
    }
  }

  async chatStream(request: NextRequest): Promise<Response> {
    try {
      const body = await request.json();
      const stream = await this.client.chatCompletionsStream(body);

      const encoder = new TextEncoder();
      const readable = new ReadableStream({
        async start(controller) {
          try {
            for await (const chunk of stream) {
              const data = `data: ${JSON.stringify(chunk)}\n\n`;
              controller.enqueue(encoder.encode(data));
            }
            controller.enqueue(encoder.encode('data: [DONE]\n\n'));
            controller.close();
          } catch (error) {
            controller.error(error);
          }
        }
      });

      return new Response(readable, {
        headers: {
          'Content-Type': 'text/event-stream',
          'Cache-Control': 'no-cache',
          'Connection': 'keep-alive'
        }
      });
    } catch (error) {
      return NextResponse.json(
        createErrorResponse(ApiErrorCode.INTERNAL_ERROR, error.message),
        { status: 500 }
      );
    }
  }
}
```

## âš ï¸ APIåº“æ¶æ„çº¦æŸ

### å¼ºåˆ¶è¦æ±‚
1. **ä¸‰å±‚æ¶æ„**: å¿…é¡»éµå¾ªåŸºç¡€å±‚â†’å¢å¼ºå±‚â†’é€‚é…å±‚çš„æ¶æ„æ¨¡å¼
2. **ç»Ÿä¸€å“åº”æ ¼å¼**: æ‰€æœ‰APIå“åº”å¿…é¡»ç¬¦åˆç»Ÿä¸€å“åº”æ ‡å‡†
3. **é”™è¯¯å¤„ç†**: å¿…é¡»æœ‰å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
4. **åè®®é€‚é…**: AG-UIé›†æˆå¿…é¡»é€šè¿‡é€‚é…å™¨å±‚
5. **ç¼“å­˜ç­–ç•¥**: ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨ç¼“å­˜æœºåˆ¶

### ç¦æ­¢äº‹é¡¹
- âŒ ç›´æ¥ä½¿ç”¨åŸºç¡€å®¢æˆ·ç«¯åœ¨ç”Ÿäº§ç¯å¢ƒ
- âŒ ç»•è¿‡é€‚é…å™¨å±‚ç›´æ¥é›†æˆAG-UI
- âŒ åˆ›å»ºé‡å¤åŠŸèƒ½çš„APIå®¢æˆ·ç«¯
- âŒ ä¸ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶
- âŒ å¿½ç•¥APIå“åº”ç¼“å­˜

### æœ€ä½³å®è·µ
- âœ… ä½¿ç”¨è¿æ¥æ± ç®¡ç†HTTPè¿æ¥
- âœ… å®æ–½æŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥
- âœ… ç›‘æ§APIè°ƒç”¨æ€§èƒ½å’Œé”™è¯¯ç‡
- âœ… ä½¿ç”¨æµå¼å“åº”å¤„ç†å¤§æ•°æ®é‡
- âœ… å®ç°å®¢æˆ·ç«¯çº§åˆ«çš„é™æµæ§åˆ¶

---

**å‚è€ƒæ–‡æ¡£**:
- [APIåº“æ¶æ„è¯´æ˜](mdc:lib/api/README.md)
- [APIè®¾è®¡æ ‡å‡†](.cursor/rules/06-api-design-standards.mdc)
- [å¼€å‘è§„èŒƒ](.cursor/rules/02-development-standards.mdc)
- [å·¥ä½œè´¨é‡ä¿è¯è§„èŒƒ](.cursor/rules/09-work-quality-assurance.mdc)
description:
globs:
alwaysApply: false
---
