---
alwaysApply: true
---
# ZK-Agent FastGPTé›†æˆè§„èŒƒ

## ğŸ“‹ FastGPTé›†æˆæ¦‚è¿°

åŸºäº [FastGPTé›†æˆæŠ€æœ¯æŒ‡å¯¼](.kiro/steering/fastgpt-integration.md) å’Œ [APIè®¾è®¡æ ‡å‡†](.cursor/rules/06-api-design-standards.mdc)ï¼ŒZK-Agentå¹³å°é€šè¿‡FastGPTå¹³å°APIé›†æˆå¤–éƒ¨æ™ºèƒ½ä½“ã€‚

### æ ¸å¿ƒé›†æˆåŸåˆ™

#### 1. æ•°æ®å­˜å‚¨åŸåˆ™ï¼ˆæ€§èƒ½ä¼˜åŒ–è¾¹ç•Œï¼‰
- **æœ¬åœ°ç¼“å­˜**: æ™ºèƒ½ä½“é…ç½®ä¿¡æ¯ï¼ˆåç§°ã€æè¿°ã€å¼€åœºç™½ã€å¤´åƒã€å…¨å±€å˜é‡ç­‰ï¼‰
  - **ä¼˜åŒ–ç›®çš„**: å‡å°‘FastGPTå¹³å°è¯·æ±‚å‹åŠ›ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
  - **ä½¿ç”¨åœºæ™¯**: ç”¨æˆ·å¼€å§‹æ–°ä¼šè¯æ—¶æ— éœ€è¯·æ±‚FastGPTæ¥å£è·å–é…ç½®
- **è¿œç¨‹å­˜å‚¨**: å¯¹è¯è®°å½•ã€ä¼šè¯å†å²ã€ç‚¹èµç‚¹å½©è®°å½•ã€ç”¨æˆ·äº¤äº’æ•°æ®ç­‰**å…¨éƒ¨**ä¿ç•™åœ¨FastGPTå¹³å°
- **é›¶åŠ¨æ€æ•°æ®**: æœ¬ç³»ç»Ÿ**ä¸å­˜å‚¨**ä»»ä½•FastGPTæ™ºèƒ½ä½“çš„å¯¹è¯è®°å½•ã€ç”¨æˆ·äº¤äº’è®°å½•
- **å®æ—¶è·å–**: æ‰€æœ‰å¯¹è¯å†å²ã€ç‚¹èµç­‰æ•°æ®é€šè¿‡FastGPTæ¥å£å®æ—¶è·å–
- **ç›´æ¥æ“ä½œ**: æ‰€æœ‰ç”¨æˆ·äº¤äº’æ“ä½œï¼ˆç‚¹èµã€æ”¶è—ç­‰ï¼‰ç›´æ¥è°ƒç”¨FastGPTæ¥å£

#### 2. APIè°ƒç”¨åŸåˆ™
- **ä»£ç†æ¨¡å¼**: æœ¬ç³»ç»Ÿä½œä¸ºFastGPTå¹³å°çš„ä»£ç†
- **é€æ˜ä¼ è¾“**: ç”¨æˆ·è¯·æ±‚é€æ˜ä¼ è¾“åˆ°FastGPTå¹³å°
- **æµå¼å“åº”**: æ”¯æŒFastGPTçš„æµå¼å“åº”ä¼ è¾“

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### ç®¡ç†ç«¯é…ç½®æµç¨‹ï¼ˆé…ç½®ç¼“å­˜ä¼˜åŒ–ï¼‰
```
ç®¡ç†å‘˜é…ç½® â†’ è¾“å…¥å¯†é’¥å’ŒAppID â†’ è°ƒç”¨FastGPTåˆå§‹åŒ–API â†’ è·å–æ™ºèƒ½ä½“é…ç½®ä¿¡æ¯ â†’ æœ¬åœ°ç¼“å­˜é…ç½®ï¼ˆå‡å°‘åç»­è¯·æ±‚ï¼‰
                                                     â†“
                                        åŒ…å«ï¼šå¼€åœºç™½ã€å…¨å±€å˜é‡ã€æ™ºèƒ½ä½“æè¿°ã€å¤´åƒç­‰é™æ€é…ç½®
```

### ç”¨æˆ·å¯¹è¯æµç¨‹ï¼ˆé…ç½®ç¼“å­˜+åŠ¨æ€è¡¨å•ï¼‰
```
ç”¨æˆ·ç™»å½• â†’ é€‰æ‹©æ™ºèƒ½ä½“ â†’ è¯»å–æœ¬åœ°ç¼“å­˜é…ç½®ï¼ˆå¼€åœºç™½ã€å…¨å±€å˜é‡å®šä¹‰ï¼‰
                                â†“
                        æ£€æŸ¥å¿…å¡«å…¨å±€å˜é‡
                                â†“
                    æœ‰å¿…å¡«å˜é‡ï¼Ÿ â†’ æ˜¾ç¤ºå…¨å±€å˜é‡è¡¨å• â†’ ç”¨æˆ·å¡«å†™/é€‰æ‹© â†’ éªŒè¯è¡¨å•
                                â†“                                         â†“
                        æ— å¿…å¡«å˜é‡                                    éªŒè¯é€šè¿‡
                                â†“                                         â†“
                        åˆ›å»ºæ–°ä¼šè¯ï¼ˆé…ç½®+ç”¨æˆ·è¾“å…¥çš„å˜é‡å€¼+FastGPT APIï¼‰
                                                        â†“
                                                å‘é€æ¶ˆæ¯åˆ°FastGPT
                                                        â†“
                                                æ¥æ”¶æµå¼å“åº” â†’ å±•ç¤ºç»™ç”¨æˆ·
                                â†“
å¯¹è¯å†å²æŸ¥çœ‹ â† å®æ—¶è·å–å†å²è®°å½•ï¼ˆFastGPT APIï¼‰
                                â†“
ç‚¹èµ/æ”¶è—æ“ä½œ â† ç›´æ¥è°ƒç”¨FastGPT APIï¼ˆæ— æœ¬åœ°å­˜å‚¨ï¼‰
```

### ç”¨æˆ·äº¤äº’æ“ä½œæµç¨‹ï¼ˆç›´æ¥ä»£ç†ï¼‰
```
ç”¨æˆ·ç‚¹èµ â†’ ç›´æ¥è°ƒç”¨FastGPTç‚¹èµAPI â†’ è¿”å›ç»“æœç»™ç”¨æˆ·
ç”¨æˆ·æ”¶è— â†’ ç›´æ¥è°ƒç”¨FastGPTæ”¶è—API â†’ è¿”å›ç»“æœç»™ç”¨æˆ·
æŸ¥çœ‹å†å² â†’ ç›´æ¥è°ƒç”¨FastGPTå†å²API â†’ è¿”å›æ•°æ®ç»™ç”¨æˆ·
```

### ç›®å½•ç»“æ„æ ‡å‡†
```
components/fastgpt/
â”œâ”€â”€ agent-selector.tsx          # æ™ºèƒ½ä½“é€‰æ‹©å™¨
â”œâ”€â”€ chat-interface.tsx          # å¯¹è¯ç•Œé¢
â”œâ”€â”€ config-panel.tsx            # é…ç½®é¢æ¿
â”œâ”€â”€ stream-handler.tsx          # æµå¼å“åº”å¤„ç†
â””â”€â”€ admin/
    â”œâ”€â”€ agent-manager.tsx       # æ™ºèƒ½ä½“ç®¡ç†
    â”œâ”€â”€ api-config.tsx          # APIé…ç½®
    â””â”€â”€ sync-monitor.tsx        # åŒæ­¥ç›‘æ§

lib/api/
â”œâ”€â”€ fastgpt-client.ts           # åŸºç¡€å®¢æˆ·ç«¯
â”œâ”€â”€ enhanced-fastgpt-client.ts  # å¢å¼ºå®¢æˆ·ç«¯
â””â”€â”€ fastgpt-ag-ui-adapter.ts    # AG-UIåè®®é€‚é…

contexts/
â””â”€â”€ FastGPTContext.tsx          # å…¨å±€çŠ¶æ€ç®¡ç†

app/api/fastgpt/
â”œâ”€â”€ agents/                     # æ™ºèƒ½ä½“API
â”œâ”€â”€ chat/                       # å¯¹è¯API
â”œâ”€â”€ config/                     # é…ç½®API
â””â”€â”€ sync/                       # åŒæ­¥API
```

## ğŸ”Œ APIå®¢æˆ·ç«¯æ¶æ„

### åŸºç¡€å®¢æˆ·ç«¯å®ç°
```typescript
/**
 * FastGPTåŸºç¡€å®¢æˆ·ç«¯
 *
 * æä¾›ä¸FastGPTå¹³å°çš„åŸºç¡€APIäº¤äº’åŠŸèƒ½
 */
export class FastGPTClient {
  private apiKey: string;
  private baseUrl: string;
  private timeout: number;

  constructor(config: FastGPTConfig) {
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://api.fastgpt.in';
    this.timeout = config.timeout || 30000;
  }

  /**
   * è·å–æ™ºèƒ½ä½“åˆ—è¡¨
   *
   * @returns Promise<FastGPTAgent[]> - æ™ºèƒ½ä½“åˆ—è¡¨
   *
   * @example
   * ```typescript
   * const client = new FastGPTClient({ apiKey: 'your-api-key' });
   * const agents = await client.getAgents();
   * ```
   */
  async getAgents(): Promise<FastGPTAgent[]> {
    try {
      const response = await this.request('/api/core/app/list', {
        method: 'GET',
        headers: this.getHeaders()
      });

      return response.data.map(this.transformAgentData);
    } catch (error) {
      throw new FastGPTAPIError(`è·å–æ™ºèƒ½ä½“åˆ—è¡¨å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * åˆ›å»ºæ–°ä¼šè¯ï¼ˆæ”¯æŒå…¨å±€å˜é‡ï¼‰
   *
   * @param appId - æ™ºèƒ½ä½“åº”ç”¨ID
   * @param globalVariables - å…¨å±€å˜é‡å€¼
   * @returns Promise<SessionCreateResponse> - ä¼šè¯åˆ›å»ºå“åº”
   */
  async createSession(
    appId: string,
    globalVariables?: Record<string, any>
  ): Promise<SessionCreateResponse> {
    try {
      const payload = {
        appId,
        variables: globalVariables || {}
      };

      const response = await this.request('/api/v1/chat/session', {
        method: 'POST',
        headers: this.getHeaders(),
        body: JSON.stringify(payload)
      });

      return {
        sessionId: response.sessionId,
        success: true,
        message: 'ä¼šè¯åˆ›å»ºæˆåŠŸ'
      };
    } catch (error) {
      throw new FastGPTAPIError(`ä¼šè¯åˆ›å»ºå¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å‘é€å¯¹è¯æ¶ˆæ¯
   *
   * @param appId - æ™ºèƒ½ä½“åº”ç”¨ID
   * @param message - ç”¨æˆ·æ¶ˆæ¯
   * @param sessionId - ä¼šè¯ID
   * @param stream - æ˜¯å¦æµå¼å“åº”
   * @returns Promise<FastGPTChatResponse> - å¯¹è¯å“åº”
   */
  async chatCompletions(
    appId: string,
    message: string,
    sessionId?: string,
    stream: boolean = false
  ): Promise<FastGPTChatResponse> {
    try {
      const payload = {
        appId,
        stream,
        detail: false,
        messages: [
          {
            content: message,
            role: 'user'
          }
        ],
        ...(sessionId && { chatId: sessionId })
      };

      if (stream) {
        return this.handleStreamResponse(payload);
      } else {
        const response = await this.request('/api/v1/chat/completions', {
          method: 'POST',
          headers: this.getHeaders(),
          body: JSON.stringify(payload)
        });

        return this.transformChatResponse(response);
      }
    } catch (error) {
      throw new FastGPTAPIError(`å¯¹è¯è¯·æ±‚å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å¤„ç†æµå¼å“åº”
   */
  private async *handleStreamResponse(payload: any): AsyncGenerator<FastGPTStreamChunk> {
    const response = await fetch(`${this.baseUrl}/api/v1/chat/completions`, {
      method: 'POST',
      headers: {
        ...this.getHeaders(),
        'Accept': 'text/event-stream'
      },
      body: JSON.stringify({ ...payload, stream: true })
    });

    if (!response.ok) {
      throw new FastGPTAPIError(`Stream request failed: ${response.statusText}`);
    }

    const reader = response.body?.getReader();
    if (!reader) {
      throw new FastGPTAPIError('æ— æ³•è·å–å“åº”æµ');
    }

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = new TextDecoder().decode(value);
        const lines = chunk.split('\n').filter(line => line.trim());

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data === '[DONE]') return;

            try {
              const parsed = JSON.parse(data);
              yield this.transformStreamChunk(parsed);
            } catch (e) {
              // å¿½ç•¥è§£æé”™è¯¯
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  /**
   * è·å–è¯·æ±‚å¤´
   */
  private getHeaders(): Record<string, string> {
    return {
      'Authorization': `Bearer ${this.apiKey}`,
      'Content-Type': 'application/json',
      'User-Agent': 'ZK-Agent/1.0'
    };
  }
}
```

### å¢å¼ºå®¢æˆ·ç«¯å®ç°
```typescript
/**
 * å¢å¼ºç‰ˆFastGPTå®¢æˆ·ç«¯
 *
 * åœ¨åŸºç¡€å®¢æˆ·ç«¯åŸºç¡€ä¸Šå¢åŠ ç¼“å­˜ã€é‡è¯•ã€äº‹ä»¶æœºåˆ¶ç­‰åŠŸèƒ½
 */
export class EnhancedFastGPTClient extends FastGPTClient {
  private cache: Map<string, any> = new Map();
  private eventEmitter: EventEmitter = new EventEmitter();
  private retryConfig: RetryConfig;

  constructor(config: EnhancedFastGPTConfig) {
    super(config);
    this.retryConfig = {
      maxRetries: config.maxRetries || 3,
      retryDelay: config.retryDelay || 1000,
      exponentialBackoff: config.exponentialBackoff || true
    };
  }

  /**
   * å¸¦ç¼“å­˜çš„å¯¹è¯è¯·æ±‚
   *
   * @param appId - æ™ºèƒ½ä½“åº”ç”¨ID
   * @param message - ç”¨æˆ·æ¶ˆæ¯
   * @param cacheKey - ç¼“å­˜é”®
   * @param ttl - ç¼“å­˜æœ‰æ•ˆæœŸï¼ˆæ¯«ç§’ï¼‰
   * @returns Promise<FastGPTChatResponse> - å¯¹è¯å“åº”
   */
  async chatCompletionsWithCache(
    appId: string,
    message: string,
    cacheKey?: string,
    ttl: number = 300000 // 5åˆ†é’Ÿé»˜è®¤ç¼“å­˜
  ): Promise<FastGPTChatResponse> {
    const key = cacheKey || `${appId}:${message}`;

    // æ£€æŸ¥ç¼“å­˜
    const cached = this.getFromCache(key);
    if (cached) {
      this.eventEmitter.emit('cache_hit', { key, data: cached });
      return cached;
    }

    // å‘é€è¯·æ±‚å¹¶ç¼“å­˜ç»“æœ
    const response = await this.chatCompletions(appId, message);
    this.setCache(key, response, ttl);

    this.eventEmitter.emit('cache_miss', { key, data: response });
    return response;
  }

  /**
   * å¸¦é‡è¯•çš„è¯·æ±‚
   */
  async requestWithRetry<T>(
    url: string,
    options: RequestInit,
    retries: number = this.retryConfig.maxRetries
  ): Promise<T> {
    try {
      return await this.request(url, options);
    } catch (error) {
      if (retries > 0 && this.shouldRetry(error)) {
        const delay = this.calculateRetryDelay(this.retryConfig.maxRetries - retries);

        this.eventEmitter.emit('retry', {
          url,
          error: error.message,
          remainingRetries: retries - 1,
          delay
        });

        await this.sleep(delay);
        return this.requestWithRetry(url, options, retries - 1);
      }
      throw error;
    }
  }

  /**
   * åˆ›å»ºæ–°ä¼šè¯ï¼ˆæ”¯æŒå…¨å±€å˜é‡å’Œç¼“å­˜é…ç½®ï¼‰
   *
   * @param appId - æ™ºèƒ½ä½“åº”ç”¨ID
   * @param userVariables - ç”¨æˆ·è¾“å…¥çš„å…¨å±€å˜é‡å€¼
   * @param cachedConfig - æœ¬åœ°ç¼“å­˜çš„æ™ºèƒ½ä½“é…ç½®
   * @returns Promise<SessionCreateResponse> - ä¼šè¯åˆ›å»ºå“åº”
   */
  async createSessionWithVariables(
    appId: string,
    userVariables: Record<string, any>,
    cachedConfig: CachedAgentConfig
  ): Promise<SessionCreateResponse> {
    try {
      // æ„å»ºå…¨å±€å˜é‡å‚æ•°
      const formHandler = new GlobalVariableFormHandler(cachedConfig);
      const sessionVariables = formHandler.buildSessionVariables(userVariables);

      // è°ƒç”¨åŸºç¡€å®¢æˆ·ç«¯åˆ›å»ºä¼šè¯
      return await this.createSession(appId, sessionVariables);
    } catch (error) {
      throw new FastGPTAPIError(`ä¼šè¯åˆ›å»ºå¤±è´¥: ${error.message}`);
    }
  }

  /**
   * éªŒè¯å…¨å±€å˜é‡è¾“å…¥
   *
   * @param cachedConfig - æ™ºèƒ½ä½“é…ç½®
   * @param userInputs - ç”¨æˆ·è¾“å…¥
   * @returns ValidationResult - éªŒè¯ç»“æœ
   */
  validateGlobalVariables(
    cachedConfig: CachedAgentConfig,
    userInputs: Record<string, any>
  ): ValidationResult {
    const formHandler = new GlobalVariableFormHandler(cachedConfig);
    return formHandler.validateInputs(userInputs);
  }

  /**
   * äº‹ä»¶ç›‘å¬å™¨
   */
  on(event: string, listener: Function): void {
    this.eventEmitter.on(event, listener);
  }

  /**
   * ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
   */
  off(event: string, listener: Function): void {
    this.eventEmitter.off(event, listener);
  }
}
```

## ğŸ”„ AG-UIåè®®é€‚é…

### FastGPT-AG-UIé€‚é…å™¨
```typescript
/**
 * FastGPTä¸AG-UIåè®®é€‚é…å™¨
 *
 * å°†FastGPTçš„å¯¹è¯æµè½¬æ¢ä¸ºAG-UIæ ‡å‡†åè®®
 */
export class FastGptAgUiAdapter {
  private client: EnhancedFastGPTClient;
  private threadId: string;
  private runId: string;

  constructor(
    client: EnhancedFastGPTClient,
    threadId: string,
    runId: string
  ) {
    this.client = client;
    this.threadId = threadId;
    this.runId = runId;
  }

  /**
   * è½¬æ¢ä¸ºAG-UIæ¶ˆæ¯æ ¼å¼
   */
  async convertToAgUiMessage(
    appId: string,
    userMessage: string
  ): Promise<AgUiMessage> {
    try {
      // å‘é€åˆ°FastGPT
      const response = await this.client.chatCompletions(appId, userMessage, this.threadId);

      // è½¬æ¢ä¸ºAG-UIæ ¼å¼
      return {
        id: generateMessageId(),
        threadId: this.threadId,
        runId: this.runId,
        role: 'assistant',
        content: response.choices[0].message.content,
        timestamp: new Date().toISOString(),
        metadata: {
          source: 'fastgpt',
          appId,
          usage: response.usage
        }
      };
    } catch (error) {
      throw new AgUiAdapterError(`æ¶ˆæ¯è½¬æ¢å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å¤„ç†æµå¼å“åº”è½¬æ¢
   */
  async *convertStreamToAgUi(
    appId: string,
    userMessage: string
  ): AsyncGenerator<AgUiStreamEvent> {
    try {
      const stream = this.client.chatCompletionsStream(appId, userMessage, this.threadId);

      for await (const chunk of stream) {
        yield {
          event: 'thread.message.delta',
          data: {
            id: generateMessageId(),
            threadId: this.threadId,
            runId: this.runId,
            delta: {
              content: [{
                type: 'text',
                text: { value: chunk.choices[0].delta.content || '' }
              }]
            }
          }
        };
      }

      // å‘é€å®Œæˆäº‹ä»¶
      yield {
        event: 'thread.message.completed',
        data: {
          id: generateMessageId(),
          threadId: this.threadId,
          runId: this.runId,
          status: 'completed'
        }
      };
    } catch (error) {
      yield {
        event: 'thread.run.failed',
        data: {
          id: this.runId,
          threadId: this.threadId,
          status: 'failed',
          last_error: {
            code: 'fastgpt_error',
            message: error.message
          }
        }
      };
    }
  }
}
```

## ğŸ¯ é…ç½®ç¼“å­˜ç­–ç•¥ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰

### è®¾è®¡åŸç†
æœ¬ç³»ç»Ÿé‡‡ç”¨"**é…ç½®æœ¬åœ°åŒ–ï¼Œæ•°æ®è¿œç¨‹åŒ–**"çš„æ¶æ„è®¾è®¡ï¼š

#### é…ç½®ä¿¡æ¯æœ¬åœ°ç¼“å­˜
- **ä¼˜åŒ–ç›®çš„**: å‡å°‘FastGPTå¹³å°è¯·æ±‚å‹åŠ›ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
- **ç¼“å­˜å†…å®¹**: æ™ºèƒ½ä½“é™æ€é…ç½®ï¼ˆå¼€åœºç™½ã€å…¨å±€å˜é‡ã€æè¿°ã€å¤´åƒç­‰ï¼‰
- **ä½¿ç”¨åœºæ™¯**: ç”¨æˆ·å¼€å§‹æ–°ä¼šè¯æ—¶ï¼Œç›´æ¥ä½¿ç”¨æœ¬åœ°ç¼“å­˜é…ç½®ï¼Œæ— éœ€è¯·æ±‚FastGPTæ¥å£

#### æ•°æ®ä»£ç†æ¶æ„
- **åŠ¨æ€æ•°æ®**: å¯¹è¯è®°å½•ã€ç‚¹èµè®°å½•ã€ç”¨æˆ·äº¤äº’ç­‰å®æ—¶é€šè¿‡FastGPT APIè·å–
- **æ“ä½œä»£ç†**: æ‰€æœ‰ç”¨æˆ·æ“ä½œç›´æ¥è°ƒç”¨FastGPT APIï¼Œæœ¬ç³»ç»Ÿä¸å­˜å‚¨

### æœ¬åœ°ç¼“å­˜é…ç½®æ¨¡å‹
```typescript
interface CachedAgentConfig {
  id: string;
  name: string;
  description: string;
  avatar: string;
  openingMessage: string;    // å¼€åœºç™½ - ä¼šè¯åˆ›å»ºæ—¶ç›´æ¥ä½¿ç”¨ï¼Œæ— éœ€APIè¯·æ±‚
  globalVariables: GlobalVariableConfig[];  // å…¨å±€å˜é‡é…ç½® - åŒ…å«è¡¨å•å®šä¹‰
  systemPrompt?: string;     // ç³»ç»Ÿæç¤ºè¯
  welcomeText?: string;      // æ¬¢è¿æ–‡æœ¬
  lastUpdated: string;       // æœ€åæ›´æ–°æ—¶é—´
  fastgptAppId: string;      // FastGPTåº”ç”¨ID
  cacheExpiry: string;       // ç¼“å­˜è¿‡æœŸæ—¶é—´
}

interface GlobalVariableConfig {
  key: string;              // å˜é‡é”®å
  label: string;            // æ˜¾ç¤ºæ ‡ç­¾
  type: 'string' | 'number' | 'boolean' | 'select' | 'textarea';  // è¾“å…¥ç±»å‹
  required: boolean;        // æ˜¯å¦å¿…å¡«
  defaultValue?: any;       // é»˜è®¤å€¼
  placeholder?: string;     // è¾“å…¥æç¤º
  options?: SelectOption[]; // é€‰æ‹©é¡¹ï¼ˆtypeä¸ºselectæ—¶ï¼‰
  validation?: {            // éªŒè¯è§„åˆ™
    min?: number;
    max?: number;
    pattern?: string;
    message?: string;
  };
}

interface SelectOption {
  label: string;
  value: string | number;
}
```

### ç¼“å­˜ç”Ÿå‘½å‘¨æœŸç®¡ç†
- **åˆå§‹åŒ–**: æ™ºèƒ½ä½“é…ç½®æ—¶ä¸€æ¬¡æ€§è·å–å¹¶ç¼“å­˜æ‰€æœ‰é™æ€é…ç½®
- **æ›´æ–°ç­–ç•¥**: å®šæœŸåŒæ­¥æ›´æ–°ï¼Œä½†ä¸å½±å“å®æ—¶ä¼šè¯æ€§èƒ½
- **å¤±æ•ˆæœºåˆ¶**: ç¼“å­˜è¿‡æœŸæ—¶é‡æ–°ä»FastGPTè·å–æœ€æ–°é…ç½®
- **æ€§èƒ½æ”¶ç›Š**: æ¯æ¬¡ç”¨æˆ·åˆ›å»ºæ–°ä¼šè¯å‡å°‘1-2æ¬¡FastGPT APIè°ƒç”¨

### å…¨å±€å˜é‡è¡¨å•å¤„ç†ç»„ä»¶
```typescript
/**
 * å…¨å±€å˜é‡è¡¨å•å¤„ç†å™¨
 *
 * æ ¹æ®FastGPTæ™ºèƒ½ä½“çš„å…¨å±€å˜é‡é…ç½®åŠ¨æ€ç”Ÿæˆè¡¨å•
 * æ”¯æŒå¿…å¡«éªŒè¯å’Œå¤šç§è¾“å…¥ç±»å‹
 */
export class GlobalVariableFormHandler {
  private agentConfig: CachedAgentConfig;

  constructor(agentConfig: CachedAgentConfig) {
    this.agentConfig = agentConfig;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰å¿…å¡«çš„å…¨å±€å˜é‡
   *
   * @returns boolean - æ˜¯å¦éœ€è¦æ˜¾ç¤ºè¡¨å•
   */
  hasRequiredVariables(): boolean {
    return this.agentConfig.globalVariables.some(variable => variable.required);
  }

  /**
   * è·å–å¿…å¡«å˜é‡åˆ—è¡¨
   *
   * @returns GlobalVariableConfig[] - å¿…å¡«å˜é‡é…ç½®
   */
  getRequiredVariables(): GlobalVariableConfig[] {
    return this.agentConfig.globalVariables.filter(variable => variable.required);
  }

  /**
   * éªŒè¯ç”¨æˆ·è¾“å…¥çš„å˜é‡å€¼
   *
   * @param userInputs - ç”¨æˆ·è¾“å…¥çš„å˜é‡å€¼
   * @returns ValidationResult - éªŒè¯ç»“æœ
   */
  validateInputs(userInputs: Record<string, any>): ValidationResult {
    const errors: ValidationError[] = [];

    for (const variable of this.agentConfig.globalVariables) {
      if (variable.required && !userInputs[variable.key]) {
        errors.push({
          field: variable.key,
          message: `${variable.label}æ˜¯å¿…å¡«é¡¹`
        });
        continue;
      }

      const value = userInputs[variable.key];
      if (value !== undefined && variable.validation) {
        const validationError = this.validateValue(variable, value);
        if (validationError) {
          errors.push(validationError);
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * æ„å»ºåˆ›å»ºä¼šè¯çš„å˜é‡å‚æ•°
   *
   * @param userInputs - ç”¨æˆ·è¾“å…¥
   * @returns Record<string, any> - å¤„ç†åçš„å˜é‡å‚æ•°
   */
  buildSessionVariables(userInputs: Record<string, any>): Record<string, any> {
    const sessionVariables: Record<string, any> = {};

    for (const variable of this.agentConfig.globalVariables) {
      const userValue = userInputs[variable.key];

      if (userValue !== undefined) {
        sessionVariables[variable.key] = userValue;
      } else if (variable.defaultValue !== undefined) {
        sessionVariables[variable.key] = variable.defaultValue;
      }
    }

    return sessionVariables;
  }

  /**
   * å•ä¸ªå€¼éªŒè¯
   */
  private validateValue(variable: GlobalVariableConfig, value: any): ValidationError | null {
    const { validation } = variable;
    if (!validation) return null;

    // å­—ç¬¦ä¸²é•¿åº¦éªŒè¯
    if (variable.type === 'string' || variable.type === 'textarea') {
      if (validation.min && value.length < validation.min) {
        return {
          field: variable.key,
          message: validation.message || `${variable.label}é•¿åº¦ä¸èƒ½å°‘äº${validation.min}ä¸ªå­—ç¬¦`
        };
      }
      if (validation.max && value.length > validation.max) {
        return {
          field: variable.key,
          message: validation.message || `${variable.label}é•¿åº¦ä¸èƒ½è¶…è¿‡${validation.max}ä¸ªå­—ç¬¦`
        };
      }
    }

    // æ•°å­—èŒƒå›´éªŒè¯
    if (variable.type === 'number') {
      const numValue = Number(value);
      if (validation.min !== undefined && numValue < validation.min) {
        return {
          field: variable.key,
          message: validation.message || `${variable.label}ä¸èƒ½å°äº${validation.min}`
        };
      }
      if (validation.max !== undefined && numValue > validation.max) {
        return {
          field: variable.key,
          message: validation.message || `${variable.label}ä¸èƒ½å¤§äº${validation.max}`
        };
      }
    }

    // æ­£åˆ™è¡¨è¾¾å¼éªŒè¯
    if (validation.pattern && !new RegExp(validation.pattern).test(value)) {
      return {
        field: variable.key,
        message: validation.message || `${variable.label}æ ¼å¼ä¸æ­£ç¡®`
      };
    }

    return null;
  }
}

interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}

interface ValidationError {
  field: string;
  message: string;
}
```

## ğŸ“Š æ•°æ®åŒæ­¥ç®¡ç†

### æ™ºèƒ½ä½“åŒæ­¥å™¨
```typescript
/**
 * FastGPTæ™ºèƒ½ä½“åŒæ­¥ç®¡ç†å™¨
 */
export class FastGPTSyncManager {
  private client: EnhancedFastGPTClient;
  private database: Database;
  private syncInterval: number;

  constructor(
    client: EnhancedFastGPTClient,
    database: Database,
    syncInterval: number = 3600000 // 1å°æ—¶
  ) {
    this.client = client;
    this.database = database;
    this.syncInterval = syncInterval;
  }

  /**
   * åŒæ­¥æ™ºèƒ½ä½“ä¿¡æ¯
   */
  async syncAgents(): Promise<SyncResult> {
    try {
      // ä»FastGPTè·å–æœ€æ–°æ™ºèƒ½ä½“åˆ—è¡¨
      const remoteAgents = await this.client.getAgents();

      // è·å–æœ¬åœ°æ™ºèƒ½ä½“åˆ—è¡¨
      const localAgents = await this.database.fastgptAgents.findMany();

      // æ‰§è¡ŒåŒæ­¥æ“ä½œ
      const syncResult = await this.performSync(remoteAgents, localAgents);

      // è®°å½•åŒæ­¥æ—¥å¿—
      await this.logSyncResult(syncResult);

      return syncResult;
    } catch (error) {
      throw new SyncError(`æ™ºèƒ½ä½“åŒæ­¥å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å¯åŠ¨å®šæ—¶åŒæ­¥
   */
  startPeriodicSync(): void {
    setInterval(async () => {
      try {
        await this.syncAgents();
        console.log('æ™ºèƒ½ä½“å®šæ—¶åŒæ­¥å®Œæˆ');
      } catch (error) {
        console.error('å®šæ—¶åŒæ­¥å¤±è´¥:', error);
      }
    }, this.syncInterval);
  }

  /**
   * æ‰§è¡ŒåŒæ­¥æ“ä½œ
   */
  private async performSync(
    remoteAgents: FastGPTAgent[],
    localAgents: LocalFastGPTAgent[]
  ): Promise<SyncResult> {
    const result: SyncResult = {
      created: 0,
      updated: 0,
      deleted: 0,
      unchanged: 0,
      errors: []
    };

    // åˆ›å»ºæˆ–æ›´æ–°è¿œç¨‹æ™ºèƒ½ä½“
    for (const remoteAgent of remoteAgents) {
      try {
        const localAgent = localAgents.find(l => l.appId === remoteAgent.appId);

        if (!localAgent) {
          // åˆ›å»ºæ–°æ™ºèƒ½ä½“
          await this.database.fastgptAgents.create({
            data: this.transformToLocalAgent(remoteAgent)
          });
          result.created++;
        } else if (this.needsUpdate(localAgent, remoteAgent)) {
          // æ›´æ–°ç°æœ‰æ™ºèƒ½ä½“
          await this.database.fastgptAgents.update({
            where: { appId: remoteAgent.appId },
            data: this.transformToLocalAgent(remoteAgent)
          });
          result.updated++;
        } else {
          result.unchanged++;
        }
      } catch (error) {
        result.errors.push({
          appId: remoteAgent.appId,
          error: error.message
        });
      }
    }

    // åˆ é™¤æœ¬åœ°å­˜åœ¨ä½†è¿œç¨‹ä¸å­˜åœ¨çš„æ™ºèƒ½ä½“
    const remoteAppIds = remoteAgents.map(a => a.appId);
    const agentsToDelete = localAgents.filter(l => !remoteAppIds.includes(l.appId));

    for (const agent of agentsToDelete) {
      try {
        await this.database.fastgptAgents.delete({
          where: { appId: agent.appId }
        });
        result.deleted++;
      } catch (error) {
        result.errors.push({
          appId: agent.appId,
          error: error.message
        });
      }
    }

    return result;
  }
}
```

## ğŸ“ ç±»å‹å®šä¹‰

### æ¥å£å®šä¹‰
```typescript
interface SessionCreateResponse {
  sessionId: string;
  success: boolean;
  message: string;
}

interface FastGPTChatResponse {
  content: string;
  sessionId?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

interface FastGPTStreamChunk {
  id: string;
  choices: Array<{
    delta: {
      content: string;
    };
    finish_reason?: string;
  }>;
}

interface FastGPTAPIError extends Error {
  status?: number;
  code?: string;
}
```

## âš ï¸ é›†æˆçº¦æŸ

### å‰ç«¯ç»„ä»¶ç¤ºä¾‹ï¼ˆå…¨å±€å˜é‡è¡¨å•ï¼‰
```typescript
/**
 * FastGPTå…¨å±€å˜é‡è¡¨å•ç»„ä»¶
 */
import React, { useState } from 'react';
import { GlobalVariableFormHandler, CachedAgentConfig } from '@/lib/api/fastgpt-client';

interface GlobalVariableFormProps {
  agentConfig: CachedAgentConfig;
  onSubmit: (variables: Record<string, any>) => void;
  onCancel: () => void;
}

export function GlobalVariableForm({ agentConfig, onSubmit, onCancel }: GlobalVariableFormProps) {
  const [formData, setFormData] = useState<Record<string, any>>({});
  const [errors, setErrors] = useState<Record<string, string>>({});
  const formHandler = new GlobalVariableFormHandler(agentConfig);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // éªŒè¯è¾“å…¥
    const validation = formHandler.validateInputs(formData);
    if (!validation.isValid) {
      const errorMap = validation.errors.reduce((acc, error) => {
        acc[error.field] = error.message;
        return acc;
      }, {} as Record<string, string>);
      setErrors(errorMap);
      return;
    }

    // æ¸…é™¤é”™è¯¯å¹¶æäº¤
    setErrors({});
    onSubmit(formData);
  };

  const handleInputChange = (key: string, value: any) => {
    setFormData(prev => ({ ...prev, [key]: value }));
    // æ¸…é™¤è¯¥å­—æ®µçš„é”™è¯¯
    if (errors[key]) {
      setErrors(prev => ({ ...prev, [key]: '' }));
    }
  };

  // æ¸²æŸ“è¾“å…¥å­—æ®µ
  const renderField = (variable: GlobalVariableConfig) => {
    const value = formData[variable.key] || variable.defaultValue || '';
    const error = errors[variable.key];

    switch (variable.type) {
      case 'string':
        return (
          <input
            type="text"
            value={value}
            placeholder={variable.placeholder}
            onChange={(e) => handleInputChange(variable.key, e.target.value)}
            className={`form-input ${error ? 'error' : ''}`}
          />
        );

      case 'textarea':
        return (
          <textarea
            value={value}
            placeholder={variable.placeholder}
            onChange={(e) => handleInputChange(variable.key, e.target.value)}
            className={`form-textarea ${error ? 'error' : ''}`}
          />
        );

      case 'number':
        return (
          <input
            type="number"
            value={value}
            min={variable.validation?.min}
            max={variable.validation?.max}
            onChange={(e) => handleInputChange(variable.key, Number(e.target.value))}
            className={`form-input ${error ? 'error' : ''}`}
          />
        );

      case 'select':
        return (
          <select
            value={value}
            onChange={(e) => handleInputChange(variable.key, e.target.value)}
            className={`form-select ${error ? 'error' : ''}`}
          >
            <option value="">è¯·é€‰æ‹©...</option>
            {variable.options?.map(option => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
        );

      case 'boolean':
        return (
          <input
            type="checkbox"
            checked={value}
            onChange={(e) => handleInputChange(variable.key, e.target.checked)}
            className="form-checkbox"
          />
        );

      default:
        return null;
    }
  };

  return (
    <form onSubmit={handleSubmit} className="global-variable-form">
      <div className="form-header">
        <h3>é…ç½®æ™ºèƒ½ä½“å‚æ•°</h3>
        <p>è¯·å¡«å†™ä»¥ä¸‹å¿…å¡«å‚æ•°ä»¥å¼€å§‹å¯¹è¯</p>
      </div>

      <div className="form-fields">
        {agentConfig.globalVariables
          .filter(v => v.required)
          .map(variable => (
            <div key={variable.key} className="form-field">
              <label className="field-label">
                {variable.label}
                {variable.required && <span className="required">*</span>}
              </label>
              {renderField(variable)}
              {errors[variable.key] && (
                <span className="field-error">{errors[variable.key]}</span>
              )}
            </div>
          ))}
      </div>

      <div className="form-actions">
        <button type="button" onClick={onCancel} className="btn-cancel">
          å–æ¶ˆ
        </button>
        <button type="submit" className="btn-submit">
          å¼€å§‹å¯¹è¯
        </button>
      </div>
    </form>
  );
}
```

### å¼ºåˆ¶è¦æ±‚
1. **é…ç½®ç¼“å­˜**: æœ¬åœ°ç¼“å­˜æ™ºèƒ½ä½“é…ç½®ï¼ˆå¼€åœºç™½ã€å…¨å±€å˜é‡å®šä¹‰ï¼‰ä»¥å‡å°‘FastGPTå¹³å°å‹åŠ›
2. **å…¨å±€å˜é‡è¡¨å•**: å¿…å¡«å…¨å±€å˜é‡å¿…é¡»é€šè¿‡è¡¨å•æ”¶é›†ç”¨æˆ·è¾“å…¥
3. **é›¶åŠ¨æ€æ•°æ®**: ä¸¥æ ¼**ç¦æ­¢å­˜å‚¨**FastGPTæ™ºèƒ½ä½“çš„å¯¹è¯è®°å½•ã€ç”¨æˆ·äº¤äº’ã€ç‚¹èµç‚¹å½©ç­‰æ•°æ®
4. **å®æ—¶è·å–**: æ‰€æœ‰å¯¹è¯å†å²ã€ç”¨æˆ·äº¤äº’è®°å½•å¿…é¡»é€šè¿‡FastGPT APIå®æ—¶è·å–
5. **ç›´æ¥æ“ä½œ**: æ‰€æœ‰ç”¨æˆ·æ“ä½œï¼ˆç‚¹èµã€æ”¶è—ã€è¯„è®ºç­‰ï¼‰å¿…é¡»ç›´æ¥è°ƒç”¨FastGPT APIï¼Œä¸å¾—æœ¬åœ°ç¼“å­˜
6. **APIä»£ç†æ¨¡å¼**: æ‰€æœ‰FastGPTè°ƒç”¨å¿…é¡»é€šè¿‡ä»£ç†ï¼Œä¸å…è®¸å‰ç«¯ç›´æ¥è°ƒç”¨
7. **æ•°æ®è¾¹ç•Œ**: æœ¬åœ°ä»…å­˜å‚¨æ™ºèƒ½ä½“åŸºç¡€å…ƒæ•°æ®ï¼ˆåç§°ã€æè¿°ã€é…ç½®ç­‰ï¼‰
8. **æµå¼æ”¯æŒ**: å¿…é¡»æ”¯æŒFastGPTçš„æµå¼å“åº”
9. **é”™è¯¯å¤„ç†**: å¿…é¡»æœ‰å®Œå–„çš„é”™è¯¯æ¢å¤å’Œé‡è¯•æœºåˆ¶
10. **åŒæ­¥æœºåˆ¶**: å¿…é¡»å®ç°æ™ºèƒ½ä½“å…ƒæ•°æ®çš„å®šæœŸåŒæ­¥å’Œå¢é‡åŒæ­¥

### æœ€ä½³å®è·µ
1. **ç¼“å­˜ç­–ç•¥**: åˆç†ä½¿ç”¨ç¼“å­˜å‡å°‘APIè°ƒç”¨
2. **ç›‘æ§å‘Šè­¦**: ç›‘æ§APIè°ƒç”¨é¢‘ç‡å’Œé”™è¯¯ç‡
3. **é…ç½®ç®¡ç†**: ç»Ÿä¸€ç®¡ç†APIå¯†é’¥å’Œé…ç½®ä¿¡æ¯
4. **ç‰ˆæœ¬å…¼å®¹**: ä¿æŒä¸FastGPT APIç‰ˆæœ¬çš„å…¼å®¹æ€§

---

**å‚è€ƒæ–‡æ¡£**:
- [FastGPTé›†æˆæŠ€æœ¯æŒ‡å¯¼](.kiro/steering/fastgpt-integration.md)
- [APIè®¾è®¡æ ‡å‡†](.cursor/rules/06-api-design-standards.mdc)
- [APIåº“æ¶æ„è§„èŒƒ](.cursor/rules/10-api-library-architecture.mdc)
- [æŠ€æœ¯æ ˆå’ŒAIæ¨¡å‹ç®¡ç†è§„èŒƒ](.cursor/rules/08-tech-stack-ai-models.mdc)
