---
alwaysApply: true
---
# ZK-Agent APIè®¾è®¡ä¸æ¥å£è§„èŒƒ

## ğŸ“‹ APIè®¾è®¡åŸåˆ™

åŸºäº [APIæ–‡æ¡£](mdc:docs/API.md) å’Œ [FastGPTé›†æˆè§„èŒƒ](.kiro/steering/fastgpt-integration.md)ï¼Œç¡®ä¿APIçš„ä¸€è‡´æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

### æ ¸å¿ƒè®¾è®¡åŸåˆ™
- **RESTfulé£æ ¼**: ä¸¥æ ¼éµå¾ªRESTæ¶æ„åŸåˆ™
- **OpenAPIè§„èŒƒ**: æ‰€æœ‰APIå¿…é¡»ä½¿ç”¨OpenAPI 3.0è§„èŒƒæè¿°
- **ç‰ˆæœ¬æ§åˆ¶**: æ”¯æŒAPIç‰ˆæœ¬ç®¡ç†å’Œå‘åå…¼å®¹
- **ç»Ÿä¸€å“åº”**: æ‰€æœ‰APIä½¿ç”¨ç»Ÿä¸€çš„å“åº”æ ¼å¼
- **é”™è¯¯å¤„ç†**: æ ‡å‡†åŒ–é”™è¯¯ç å’Œé”™è¯¯ä¿¡æ¯

### æŠ€æœ¯è¦æ±‚
- **è®¤è¯æ–¹å¼**: JWT + Bearer Token
- **å†…å®¹ç±»å‹**: application/json (é»˜è®¤)
- **å­—ç¬¦ç¼–ç **: UTF-8
- **å‹ç¼©æ”¯æŒ**: gzip, deflate
- **CORSé…ç½®**: é…ç½®åˆé€‚çš„è·¨åŸŸç­–ç•¥

## ğŸ”— ç»Ÿä¸€å“åº”æ ¼å¼

### æˆåŠŸå“åº”æ ‡å‡†
```typescript
// âœ… æ ‡å‡†æˆåŠŸå“åº”æ ¼å¼
interface SuccessResponse<T> {
  success: true;
  data: T;
  message?: string;
  timestamp: string;
  requestId: string;
  version: string;
}

// ç¤ºä¾‹å®ç°
export function createSuccessResponse<T>(
  data: T,
  message?: string,
  requestId?: string
): SuccessResponse<T> {
  return {
    success: true,
    data,
    message,
    timestamp: new Date().toISOString(),
    requestId: requestId || generateRequestId(),
    version: process.env.API_VERSION || '1.0.0'
  };
}
```

### é”™è¯¯å“åº”æ ‡å‡†
```typescript
// âœ… æ ‡å‡†é”™è¯¯å“åº”æ ¼å¼
interface ErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: any;
    field?: string;
    timestamp: string;
  };
  requestId: string;
  version: string;
}

// é”™è¯¯ç å®šä¹‰
export enum ApiErrorCode {
  // 4xx å®¢æˆ·ç«¯é”™è¯¯
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  NOT_FOUND = 'NOT_FOUND',
  CONFLICT = 'CONFLICT',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',

  // 5xx æœåŠ¡å™¨é”™è¯¯
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  DATABASE_ERROR = 'DATABASE_ERROR',
  THIRD_PARTY_ERROR = 'THIRD_PARTY_ERROR',

  // ä¸šåŠ¡é”™è¯¯
  AGENT_NOT_FOUND = 'AGENT_NOT_FOUND',
  AGENT_BUSY = 'AGENT_BUSY',
  INVALID_AGENT_CONFIG = 'INVALID_AGENT_CONFIG',
  CHAT_SESSION_EXPIRED = 'CHAT_SESSION_EXPIRED'
}

// ç¤ºä¾‹å®ç°
export function createErrorResponse(
  code: ApiErrorCode,
  message: string,
  details?: any,
  field?: string,
  requestId?: string
): ErrorResponse {
  return {
    success: false,
    error: {
      code,
      message,
      details,
      field,
      timestamp: new Date().toISOString()
    },
    requestId: requestId || generateRequestId(),
    version: process.env.API_VERSION || '1.0.0'
  };
}
```

## ğŸ” è®¤è¯ä¸æˆæƒè§„èŒƒ

### JWTè®¤è¯å®ç°
```typescript
// âœ… JWTè®¤è¯ä¸­é—´ä»¶
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
    permissions: string[];
  };
}

/**
 * JWTè®¤è¯ä¸­é—´ä»¶
 */
export function authenticateToken(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json(
        createErrorResponse(
          ApiErrorCode.UNAUTHORIZED,
          'ç¼ºå°‘æˆ–æ— æ•ˆçš„Authorizationå¤´éƒ¨',
          null,
          'authorization',
          req.headers['x-request-id'] as string
        )
      );
    }

    const token = authHeader.substring(7); // ç§»é™¤ 'Bearer ' å‰ç¼€
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;

    req.user = {
      id: decoded.userId,
      email: decoded.email,
      role: decoded.role,
      permissions: decoded.permissions || []
    };

    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      return res.status(401).json(
        createErrorResponse(
          ApiErrorCode.UNAUTHORIZED,
          'JWTä»¤ç‰Œæ— æ•ˆæˆ–å·²è¿‡æœŸ',
          error.message,
          'token',
          req.headers['x-request-id'] as string
        )
      );
    }

    next(error);
  }
}

/**
 * æƒé™æ£€æŸ¥ä¸­é—´ä»¶
 */
export function requirePermission(permission: string) {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json(
        createErrorResponse(
          ApiErrorCode.UNAUTHORIZED,
          'ç”¨æˆ·æœªè®¤è¯',
          null,
          null,
          req.headers['x-request-id'] as string
        )
      );
    }

    if (!req.user.permissions.includes(permission)) {
      return res.status(403).json(
        createErrorResponse(
          ApiErrorCode.FORBIDDEN,
          `ç¼ºå°‘æƒé™: ${permission}`,
          { requiredPermission: permission },
          'permissions',
          req.headers['x-request-id'] as string
        )
      );
    }

    next();
  };
}
```

### API Keyè®¤è¯ï¼ˆå¯é€‰ï¼‰
```typescript
// âœ… API Keyè®¤è¯ä¸­é—´ä»¶
export function authenticateApiKey(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    const apiKey = req.headers['x-api-key'] as string;

    if (!apiKey) {
      return res.status(401).json(
        createErrorResponse(
          ApiErrorCode.UNAUTHORIZED,
          'ç¼ºå°‘APIå¯†é’¥',
          null,
          'x-api-key'
        )
      );
    }

    // éªŒè¯APIå¯†é’¥ï¼ˆä»æ•°æ®åº“æˆ–ç¼“å­˜ä¸­æŸ¥è¯¢ï¼‰
    const isValidKey = await validateApiKey(apiKey);
    if (!isValidKey) {
      return res.status(401).json(
        createErrorResponse(
          ApiErrorCode.UNAUTHORIZED,
          'APIå¯†é’¥æ— æ•ˆ',
          null,
          'x-api-key'
        )
      );
    }

    next();
  } catch (error) {
    next(error);
  }
}
```

## ğŸ“Š åˆ†é¡µä¸æŸ¥è¯¢è§„èŒƒ

### æ ‡å‡†åˆ†é¡µå®ç°
```typescript
// âœ… åˆ†é¡µæŸ¥è¯¢æ¥å£
interface PaginationQuery {
  page?: number;        // é¡µç ï¼Œä»1å¼€å§‹
  limit?: number;       // æ¯é¡µæ•°é‡ï¼Œé»˜è®¤20ï¼Œæœ€å¤§100
  sort?: string;        // æ’åºå­—æ®µ
  order?: 'asc' | 'desc'; // æ’åºæ–¹å‘
}

interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

/**
 * åˆ†é¡µæŸ¥è¯¢å·¥å…·ç±»
 */
export class PaginationUtils {
  /**
   * æ ‡å‡†åŒ–åˆ†é¡µå‚æ•°
   */
  static normalizePagination(query: PaginationQuery) {
    const page = Math.max(1, Number(query.page) || 1);
    const limit = Math.min(100, Math.max(1, Number(query.limit) || 20));
    const offset = (page - 1) * limit;

    return { page, limit, offset };
  }

  /**
   * åˆ›å»ºåˆ†é¡µå“åº”
   */
  static createPaginatedResponse<T>(
    data: T[],
    total: number,
    page: number,
    limit: number
  ): PaginatedResponse<T> {
    const totalPages = Math.ceil(total / limit);

    return {
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
export async function getUsersHandler(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const { page, limit, offset } = PaginationUtils.normalizePagination(req.query);

    const [users, total] = await Promise.all([
      userService.getUsers({ offset, limit }),
      userService.getUserCount()
    ]);

    const response = PaginationUtils.createPaginatedResponse(
      users,
      total,
      page,
      limit
    );

    res.json(createSuccessResponse(response));
  } catch (error) {
    next(error);
  }
}
```

## ğŸš€ FastGPTé›†æˆAPIè§„èŒƒ

### FastGPTç»Ÿä¸€å®¢æˆ·ç«¯ä½¿ç”¨
```typescript
// âœ… FastGPT APIé›†æˆè§„èŒƒ
import { FastGPTClient } from '@/lib/api/fastgpt-client';
import { EnhancedFastGPTClient } from '@/lib/api/enhanced-fastgpt-client';

/**
 * FastGPTèŠå¤©æ¥å£
 */
export async function fastgptChatHandler(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const { appId, message, sessionId, stream = false } = req.body;

    // è¾“å…¥éªŒè¯
    if (!appId || !message) {
      return res.status(400).json(
        createErrorResponse(
          ApiErrorCode.VALIDATION_ERROR,
          'ç¼ºå°‘å¿…éœ€å‚æ•°: appId å’Œ message',
          { requiredFields: ['appId', 'message'] }
        )
      );
    }

    // ä½¿ç”¨å¢å¼ºå®¢æˆ·ç«¯è¿›è¡Œè°ƒç”¨
    const client = new EnhancedFastGPTClient();

    if (stream) {
      // æµå¼å“åº”
      const chatStream = await client.chatCompletionsStream({
        appId,
        messages: [{ role: 'user', content: message }],
        sessionId,
        userId: req.user!.id
      });

      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');

      for await (const chunk of chatStream) {
        if (chunk.data) {
          res.write(`data: ${JSON.stringify(chunk.data)}\n\n`);
        }
      }

      res.write('data: [DONE]\n\n');
      res.end();
    } else {
      // éæµå¼å“åº”
      const result = await client.chatCompletions({
        appId,
        messages: [{ role: 'user', content: message }],
        sessionId,
        userId: req.user!.id
      });

      res.json(createSuccessResponse({
        content: result.content,
        sessionId: result.sessionId,
        usage: result.usage
      }));
    }
  } catch (error) {
    next(error);
  }
}

/**
 * æ™ºèƒ½ä½“ç®¡ç†æ¥å£
 */
export async function createAgentHandler(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const { name, description, config, appId } = req.body;

    // æ•°æ®éªŒè¯
    const validation = validateAgentConfig({ name, description, config, appId });
    if (!validation.valid) {
      return res.status(400).json(
        createErrorResponse(
          ApiErrorCode.VALIDATION_ERROR,
          'æ™ºèƒ½ä½“é…ç½®éªŒè¯å¤±è´¥',
          validation.errors
        )
      );
    }

    // åˆ›å»ºæ™ºèƒ½ä½“
    const agent = await agentService.createAgent({
      name,
      description,
      config,
      appId,
      userId: req.user!.id
    });

    res.status(201).json(createSuccessResponse(agent, 'æ™ºèƒ½ä½“åˆ›å»ºæˆåŠŸ'));
  } catch (error) {
    next(error);
  }
}
```

## ğŸ“ æ•°æ®éªŒè¯è§„èŒƒ

### è¾“å…¥éªŒè¯ä¸­é—´ä»¶
```typescript
// âœ… æ•°æ®éªŒè¯ä¸­é—´ä»¶
import Joi from 'joi';

/**
 * åˆ›å»ºéªŒè¯ä¸­é—´ä»¶
 */
export function validateRequest(schema: {
  body?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
}) {
  return (req: Request, res: Response, next: NextFunction) => {
    const errors: string[] = [];

    // éªŒè¯è¯·æ±‚ä½“
    if (schema.body) {
      const { error } = schema.body.validate(req.body);
      if (error) {
        errors.push(...error.details.map(detail => detail.message));
      }
    }

    // éªŒè¯æŸ¥è¯¢å‚æ•°
    if (schema.query) {
      const { error } = schema.query.validate(req.query);
      if (error) {
        errors.push(...error.details.map(detail => detail.message));
      }
    }

    // éªŒè¯è·¯å¾„å‚æ•°
    if (schema.params) {
      const { error } = schema.params.validate(req.params);
      if (error) {
        errors.push(...error.details.map(detail => detail.message));
      }
    }

    if (errors.length > 0) {
      return res.status(400).json(
        createErrorResponse(
          ApiErrorCode.VALIDATION_ERROR,
          'è¯·æ±‚æ•°æ®éªŒè¯å¤±è´¥',
          errors
        )
      );
    }

    next();
  };
}

// éªŒè¯æ¨¡å¼å®šä¹‰
export const AgentSchemas = {
  create: Joi.object({
    name: Joi.string().min(1).max(100).required(),
    description: Joi.string().max(500).optional(),
    config: Joi.object({
      model: Joi.string().required(),
      temperature: Joi.number().min(0).max(1).default(0.7),
      maxTokens: Joi.number().min(1).max(4000).default(2000)
    }).required(),
    appId: Joi.string().required()
  }),

  update: Joi.object({
    name: Joi.string().min(1).max(100).optional(),
    description: Joi.string().max(500).optional(),
    config: Joi.object({
      model: Joi.string().optional(),
      temperature: Joi.number().min(0).max(1).optional(),
      maxTokens: Joi.number().min(1).max(4000).optional()
    }).optional()
  }),

  chat: Joi.object({
    appId: Joi.string().required(),
    message: Joi.string().min(1).max(10000).required(),
    sessionId: Joi.string().optional(),
    stream: Joi.boolean().default(false)
  })
};
```

## ğŸ”„ ç‰ˆæœ¬æ§åˆ¶ä¸å…¼å®¹æ€§

### APIç‰ˆæœ¬ç®¡ç†
```typescript
// âœ… APIç‰ˆæœ¬æ§åˆ¶
export enum ApiVersion {
  V1 = 'v1',
  V2 = 'v2'
}

/**
 * ç‰ˆæœ¬æ§åˆ¶ä¸­é—´ä»¶
 */
export function versionControl(supportedVersions: ApiVersion[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    // ä»URLè·¯å¾„æˆ–Headerä¸­è·å–ç‰ˆæœ¬
    const versionFromPath = req.path.match(/^\/api\/(v\d+)\//)?.[1] as ApiVersion;
    const versionFromHeader = req.headers['api-version'] as ApiVersion;

    const requestedVersion = versionFromPath || versionFromHeader || ApiVersion.V1;

    if (!supportedVersions.includes(requestedVersion)) {
      return res.status(400).json(
        createErrorResponse(
          ApiErrorCode.VALIDATION_ERROR,
          `ä¸æ”¯æŒçš„APIç‰ˆæœ¬: ${requestedVersion}`,
          { supportedVersions }
        )
      );
    }

    req.apiVersion = requestedVersion;
    next();
  };
}

// ç‰ˆæœ¬åŒ–çš„è·¯ç”±å¤„ç†
export function createVersionedHandler(handlers: Partial<Record<ApiVersion, Function>>) {
  return (req: Request, res: Response, next: NextFunction) => {
    const handler = handlers[req.apiVersion];
    if (!handler) {
      return res.status(501).json(
        createErrorResponse(
          ApiErrorCode.SERVICE_UNAVAILABLE,
          `ç‰ˆæœ¬ ${req.apiVersion} ä¸æ”¯æŒæ­¤åŠŸèƒ½`
        )
      );
    }

    return handler(req, res, next);
  };
}
```

## âš ï¸ APIå®‰å…¨è¦æ±‚

### å®‰å…¨æœ€ä½³å®è·µ
- âœ… æ‰€æœ‰APIç«¯ç‚¹å¿…é¡»é€šè¿‡è®¤è¯
- âœ… æ•æ„Ÿæ“ä½œéœ€è¦é¢å¤–æƒé™éªŒè¯
- âœ… å®æ–½è¯·æ±‚é¢‘ç‡é™åˆ¶
- âœ… è®°å½•æ‰€æœ‰APIè®¿é—®æ—¥å¿—
- âœ… è¾“å…¥æ•°æ®å¿…é¡»ç»è¿‡éªŒè¯å’Œæ¸…ç†
- âœ… ä½¿ç”¨HTTPSä¼ è¾“æ•æ„Ÿæ•°æ®
- âœ… å®æ–½CORSå®‰å…¨ç­–ç•¥

### ç¦æ­¢äº‹é¡¹
- âŒ åœ¨URLä¸­ä¼ é€’æ•æ„Ÿä¿¡æ¯
- âŒ è¿”å›è¯¦ç»†çš„ç³»ç»Ÿé”™è¯¯ä¿¡æ¯
- âŒ è·³è¿‡è¾“å…¥éªŒè¯
- âŒ ä½¿ç”¨å¼±å¯†ç ç­–ç•¥
- âŒ å¿½ç•¥APIç‰ˆæœ¬å…¼å®¹æ€§

---

**å‚è€ƒæ–‡æ¡£**:
- [APIæ–‡æ¡£](mdc:docs/API.md)
- [FastGPTé›†æˆè§„èŒƒ](.kiro/steering/fastgpt-integration.md)
- [å®‰å…¨è§„èŒƒæ–‡æ¡£](mdc:lib/security/README.md)
description:
globs:
alwaysApply: false
---
