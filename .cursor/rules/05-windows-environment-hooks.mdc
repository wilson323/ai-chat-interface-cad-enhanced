---
alwaysApply: true
---

# ZK-Agent Windows环境与开发钩子工作流程规范

## 📋 Windows环境特殊要求

基于 [开发工作流程增强钩子](.kiro/hooks/development-workflow-enhancement.kiro.hook) 和 [项目标准合规钩子](.kiro/hooks/project-standards-compliance.kiro.hook)，确保Windows环境下的开发规范性。

### 系统环境要求
- **操作系统**: Windows 10/11 (64位)
- **Shell环境**: PowerShell 5.1+ 或 PowerShell Core 7+
- **包管理**: npm/yarn + pip + conda (可选)
- **容器环境**: Docker Desktop for Windows

### PowerShell脚本规范
```powershell
# ✅ 正确的PowerShell脚本示例
param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectPath,

    [Parameter(Mandatory=$false)]
    [switch]$Force
)

# 错误处理设置
$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# 函数定义
function Test-ProjectStructure {
    <#
    .SYNOPSIS
    检查项目结构是否符合规范

    .DESCRIPTION
    验证项目目录结构、配置文件存在性、依赖完整性

    .PARAMETER Path
    项目根目录路径

    .EXAMPLE
    Test-ProjectStructure -Path "E:\zk-agent"
    #>
    param([string]$Path)

    try {
        # 检查必要目录
        $RequiredDirs = @("app", "components", "lib", "backend", "tests")
        foreach ($dir in $RequiredDirs) {
            $dirPath = Join-Path $Path $dir
            if (-not (Test-Path $dirPath)) {
                throw "缺少必要目录: $dir"
            }
        }

        # 检查配置文件
        $RequiredFiles = @("package.json", "tsconfig.json", "tailwind.config.ts")
        foreach ($file in $RequiredFiles) {
            $filePath = Join-Path $Path $file
            if (-not (Test-Path $filePath)) {
                throw "缺少必要文件: $file"
            }
        }

        Write-Output "✅ 项目结构检查通过"
        return $true
    }
    catch {
        Write-Error "❌ 项目结构检查失败: $_"
        return $false
    }
}

# 主执行逻辑
try {
    Write-Output "🔍 开始检查项目: $ProjectPath"

    if (-not (Test-Path $ProjectPath)) {
        throw "项目路径不存在: $ProjectPath"
    }

    $result = Test-ProjectStructure -Path $ProjectPath

    if ($result) {
        Write-Output "🎉 项目检查完成"
        exit 0
    } else {
        exit 1
    }
}
catch {
    Write-Error "💥 执行失败: $_"
    exit 1
}
```

### 路径处理规范
```typescript
// ✅ 正确的跨平台路径处理
import path from 'path';
import os from 'os';
import fs from 'fs/promises';

// 路径处理工具类
export class WindowsPathUtils {
  /**
   * 标准化路径分隔符
   */
  static normalizePath(inputPath: string): string {
    return path.normalize(inputPath).replace(/\\/g, '/');
  }

  /**
   * 获取安全的文件路径
   */
  static getSafeFilePath(basePath: string, fileName: string): string {
    const safeName = fileName.replace(/[<>:"|?*]/g, '_');
    return path.join(basePath, safeName);
  }

  /**
   * 检查路径是否存在且可访问
   */
  static async isAccessible(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath, fs.constants.F_OK | fs.constants.R_OK);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 创建目录（如果不存在）
   */
  static async ensureDirectory(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error: any) {
      if (error.code !== 'EEXIST') {
        throw new Error(`创建目录失败: ${dirPath}, 错误: ${error.message}`);
      }
    }
  }

  /**
   * 获取临时目录路径
   */
  static getTempPath(): string {
    return os.tmpdir();
  }

  /**
   * 处理Windows长路径问题
   */
  static handleLongPath(inputPath: string): string {
    if (process.platform === 'win32' && inputPath.length > 260) {
      return `\\\\?\\${path.resolve(inputPath)}`;
    }
    return inputPath;
  }
}
```

## 🔄 开发工作流程增强钩子

### 工作前分析流程
基于 [开发工作流程增强钩子](.kiro/hooks/development-workflow-enhancement.kiro.hook)，每次文件编辑时自动触发全面分析。

```typescript
// 自动触发文件模式
const TRIGGER_PATTERNS = [
  "**/*.py", "**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx",
  "**/*.vue", "**/*.md", "requirements.txt", "package.json",
  "pyproject.toml", "Dockerfile", "docker-compose.yml",
  ".env*", "config/**/*", "docs/**/*", "tests/**/*"
];

interface WorkflowAnalysis {
  // 阶段1：工作前质量保证分析
  mcpToolsAvailability: {
    serena: boolean;
    zen: boolean;
    memory: boolean;
    sequentialThinking: boolean;
    context7: boolean;
    time: boolean;
    git: boolean;
    fetch: boolean;
  };

  // 历史经验复用
  historicalLessons: {
    searchResults: any[];
    applicablePatterns: string[];
    riskPreventionMeasures: string[];
  };

  // 全局架构一致性
  architectureConsistency: {
    analyzisResult: any;
    moduleBoundaryCheck: boolean;
    dependencyValidation: boolean;
    complianceScore: number;
  };

  // 代码冗余检查
  redundancyValidation: {
    duplicateCodeCheck: any;
    similarModulesFound: string[];
    documentationConsistency: boolean;
  };
}
```

### 强制检查点实现
```typescript
// ✅ 工作前强制检查流程
export class WorkflowEnhancementChecker {
  private mcpTools: MCPToolsManager;
  private memoryStore: MemoryStore;
  private codeAnalyzer: CodeAnalyzer;

  constructor() {
    this.mcpTools = new MCPToolsManager();
    this.memoryStore = new MemoryStore();
    this.codeAnalyzer = new CodeAnalyzer();
  }

  /**
   * 执行完整的工作前分析
   */
  async executePreWorkAnalysis(changedFiles: string[]): Promise<WorkflowAnalysis> {
    console.log("🚀 开始执行开发工作流程增强分析...");

    // 阶段1：MCP工具可用性检查
    const mcpAvailability = await this.checkMCPToolsAvailability();
    if (!this.validateMCPToolsReady(mcpAvailability)) {
      throw new Error("MCP工具未就绪，无法继续工作");
    }

    // 阶段2：历史经验与风险预防
    const historicalData = await this.analyzeHistoricalLessons(changedFiles);

    // 阶段3：架构一致性检查
    const architectureCheck = await this.validateArchitectureConsistency(changedFiles);

    // 阶段4：冗余检查
    const redundancyCheck = await this.validateRedundancy(changedFiles);

    // 阶段5：异常状态检查
    await this.checkSystemAnomalies();

    const analysis: WorkflowAnalysis = {
      mcpToolsAvailability: mcpAvailability,
      historicalLessons: historicalData,
      architectureConsistency: architectureCheck,
      redundancyValidation: redundancyCheck
    };

    // 生成详细评估报告
    await this.generateAssessmentReport(analysis);

    console.log("✅ 工作前分析完成，可以开始开发工作");
    return analysis;
  }

  /**
   * 检查MCP工具可用性
   */
  private async checkMCPToolsAvailability() {
    const tools = {
      serena: await this.mcpTools.isSerenaAvailable(),
      zen: await this.mcpTools.isZenAvailable(),
      memory: await this.mcpTools.isMemoryAvailable(),
      sequentialThinking: await this.mcpTools.isSequentialThinkingAvailable(),
      context7: await this.mcpTools.isContext7Available(),
      time: await this.mcpTools.isTimeAvailable(),
      git: await this.mcpTools.isGitAvailable(),
      fetch: await this.mcpTools.isFetchAvailable()
    };

    console.log("🔍 MCP工具可用性检查:", tools);
    return tools;
  }

  /**
   * 验证MCP工具就绪状态
   */
  private validateMCPToolsReady(availability: any): boolean {
    const requiredTools = ['serena', 'memory', 'sequentialThinking'];
    const unavailableTools = requiredTools.filter(tool => !availability[tool]);

    if (unavailableTools.length > 0) {
      console.error(`❌ 必需的MCP工具不可用: ${unavailableTools.join(', ')}`);
      return false;
    }

    return true;
  }

  /**
   * 分析历史经验和教训
   */
  private async analyzeHistoricalLessons(files: string[]) {
    // 使用memory.search_nodes()查询相关历史经验
    const searchResults = await this.memoryStore.searchNodes({
      patterns: files.map(f => path.extname(f)),
      context: "development_experience",
      limit: 10
    });

    // 分析可复用模式
    const applicablePatterns = await this.memoryStore.findApplicablePatterns({
      currentFiles: files,
      searchResults: searchResults
    });

    // 制定风险预防措施
    const riskMeasures = await this.memoryStore.getRiskPreventionMeasures({
      patterns: applicablePatterns,
      context: "file_modification"
    });

    return {
      searchResults,
      applicablePatterns,
      riskPreventionMeasures: riskMeasures
    };
  }

  /**
   * 验证架构一致性
   */
  private async validateArchitectureConsistency(files: string[]) {
    // 使用serena.architecture_analyze()分析架构
    const analysisResult = await this.mcpTools.serena.architectureAnalyze(files);

    // 检查模块边界
    const moduleBoundaryCheck = await this.codeAnalyzer.validateModuleBoundaries(files);

    // 验证依赖关系
    const dependencyValidation = await this.codeAnalyzer.validateDependencies(files);

    // 计算合规评分
    const complianceScore = this.calculateComplianceScore({
      analysisResult,
      moduleBoundaryCheck,
      dependencyValidation
    });

    if (complianceScore < 90) {
      console.warn(`⚠️ 架构合规性评分较低: ${complianceScore}/100`);
    }

    return {
      analysisResult,
      moduleBoundaryCheck,
      dependencyValidation,
      complianceScore
    };
  }

  /**
   * 验证代码和文档冗余
   */
  private async validateRedundancy(files: string[]) {
    // 使用serena.duplicate_check()检测重复代码
    const duplicateCheck = await this.mcpTools.serena.duplicateCheck(files);

    // 搜索类似功能模块
    const similarModules = await this.codeAnalyzer.findSimilarModules(files);

    // 验证文档一致性
    const docConsistency = await this.codeAnalyzer.validateDocumentationConsistency();

    if (duplicateCheck.duplicates.length > 0) {
      console.warn(`⚠️ 发现重复代码: ${duplicateCheck.duplicates.length}处`);
    }

    return {
      duplicateCodeCheck: duplicateCheck,
      similarModulesFound: similarModules,
      documentationConsistency: docConsistency
    };
  }

  /**
   * 检查系统异常状态
   */
  private async checkSystemAnomalies() {
    // 检查上次工作遗留问题
    const pendingIssues = await this.memoryStore.getPendingIssues();

    // 验证系统运行状态
    const systemStatus = await this.checkSystemStatus();

    // 确认开发环境配置
    const envValidation = await this.validateEnvironmentConfig();

    if (pendingIssues.length > 0) {
      console.warn(`⚠️ 发现${pendingIssues.length}个遗留问题需要处理`);
    }

    if (!systemStatus.healthy) {
      throw new Error(`系统状态异常: ${systemStatus.issues.join(', ')}`);
    }

    if (!envValidation.valid) {
      throw new Error(`环境配置异常: ${envValidation.errors.join(', ')}`);
    }
  }

  /**
   * 生成评估报告
   */
  private async generateAssessmentReport(analysis: WorkflowAnalysis) {
    const report = {
      timestamp: new Date().toISOString(),
      mcpToolsStatus: analysis.mcpToolsAvailability,
      historicalInsights: analysis.historicalLessons.applicablePatterns,
      architectureScore: analysis.architectureConsistency.complianceScore,
      redundancyIssues: analysis.redundancyValidation.duplicateCodeCheck.duplicates.length,
      recommendations: this.generateRecommendations(analysis),
      readyToProceed: this.isReadyToProceed(analysis)
    };

    // 存储到memory
    await this.memoryStore.storeAssessmentReport(report);

    console.log("📊 评估报告已生成并存储");
    return report;
  }

  /**
   * 生成改进建议
   */
  private generateRecommendations(analysis: WorkflowAnalysis): string[] {
    const recommendations: string[] = [];

    if (analysis.architectureConsistency.complianceScore < 90) {
      recommendations.push("建议优化架构设计，提高合规性评分");
    }

    if (analysis.redundancyValidation.duplicateCodeCheck.duplicates.length > 0) {
      recommendations.push("建议重构重复代码，提高代码复用性");
    }

    if (analysis.redundancyValidation.similarModulesFound.length > 0) {
      recommendations.push("发现相似模块，建议合并或抽象公共功能");
    }

    return recommendations;
  }

  /**
   * 判断是否准备好继续工作
   */
  private isReadyToProceed(analysis: WorkflowAnalysis): boolean {
    // 检查阻塞条件
    const blockingIssues = [
      analysis.architectureConsistency.complianceScore < 80,
      !analysis.architectureConsistency.moduleBoundaryCheck,
      !analysis.redundancyValidation.documentationConsistency
    ];

    return !blockingIssues.some(issue => issue);
  }
}
```

## 📋 项目标准合规检查钩子

### 提交前强制检查
基于 [项目标准合规钩子](.kiro/hooks/project-standards-compliance.kiro.hook)，在每次提交前自动执行全面的合规检查。

```typescript
// 自动触发：beforeCommit事件，匹配所有文件
export class ProjectStandardsComplianceChecker {
  private serena: SerenaTools;
  private qualityGates: QualityGates;

  /**
   * 执行完整的项目规范遵循检查
   */
  async executeComplianceCheck(files: string[]): Promise<ComplianceResult> {
    console.log("📋 开始执行项目规范遵循检查...");

    const results = {
      pythonCompliance: await this.checkPythonCompliance(files),
      typescriptCompliance: await this.checkTypescriptCompliance(files),
      documentationCompliance: await this.checkDocumentationCompliance(files),
      testingCompliance: await this.checkTestingCompliance(files),
      securityCompliance: await this.checkSecurityCompliance(files),
      performanceCompliance: await this.checkPerformanceCompliance(files),
      structureCompliance: await this.checkStructureCompliance(files),
      versionControlCompliance: await this.checkVersionControlCompliance(files),
      windowsCompliance: await this.checkWindowsCompliance(files)
    };

    // 验证所有检查都通过
    const overallResult = this.validateOverallCompliance(results);

    if (!overallResult.passed) {
      throw new Error(`合规检查失败: ${overallResult.failures.join(', ')}`);
    }

    console.log("✅ 所有项目规范遵循检查通过");
    return overallResult;
  }

  /**
   * Python开发规范检查
   */
  private async checkPythonCompliance(files: string[]) {
    const pythonFiles = files.filter(f => f.endsWith('.py'));
    if (pythonFiles.length === 0) return { passed: true, issues: [] };

    const checks = [
      await this.serena.styleCheck(pythonFiles), // PEP 8检查
      await this.serena.complexityCheck(pythonFiles), // 复杂度检查
      await this.checkTypeAnnotations(pythonFiles), // 类型注解检查
      await this.checkAsyncUsage(pythonFiles), // 异步编程检查
      await this.checkExceptionHandling(pythonFiles), // 异常处理检查
      await this.checkLoggingUsage(pythonFiles) // 日志使用检查
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * TypeScript开发规范检查
   */
  private async checkTypescriptCompliance(files: string[]) {
    const tsFiles = files.filter(f => f.match(/\.(ts|tsx)$/));
    if (tsFiles.length === 0) return { passed: true, issues: [] };

    const checks = [
      await this.serena.styleCheck(tsFiles), // ESLint检查
      await this.checkStrictMode(tsFiles), // 严格模式检查
      await this.checkTypeDefinitions(tsFiles), // 类型定义检查
      await this.checkComponentStructure(tsFiles), // 组件结构检查
      await this.checkImportOrganization(tsFiles) // 导入组织检查
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * 测试规范合规检查
   */
  private async checkTestingCompliance(files: string[]) {
    const coverage = await this.serena.testCoverage(files);
    const testFiles = files.filter(f => f.match(/\.(test|spec)\.(ts|tsx|py)$/));

    const checks = [
      {
        name: "测试覆盖率检查",
        passed: coverage.percentage >= 85,
        message: `测试覆盖率: ${coverage.percentage}% (要求≥85%)`
      },
      {
        name: "测试文件存在性检查",
        passed: testFiles.length > 0 || files.length === 0,
        message: testFiles.length === 0 ? "没有找到测试文件" : "找到测试文件"
      }
    ];

    // 运行测试
    if (testFiles.length > 0) {
      const testResult = await this.serena.testRun(testFiles);
      checks.push({
        name: "测试执行检查",
        passed: testResult.success,
        message: testResult.success ? "所有测试通过" : `${testResult.failedCount}个测试失败`
      });
    }

    return this.aggregateCheckResults(checks);
  }

  /**
   * 安全规范合规检查
   */
  private async checkSecurityCompliance(files: string[]) {
    const checks = [
      await this.serena.securityScan(files), // 安全漏洞扫描
      await this.serena.secretScan(files), // 敏感信息扫描
      await this.serena.dependencyCheck(files), // 依赖安全检查
      await this.serena.permissionCheck(files) // 权限检查
    ];

    // 验证无高危漏洞
    const securityScan = checks[0];
    const highRiskVulns = securityScan.vulnerabilities?.filter(v => v.severity === 'high') || [];

    if (highRiskVulns.length > 0) {
      checks.push({
        name: "高危漏洞检查",
        passed: false,
        message: `发现${highRiskVulns.length}个高危安全漏洞`
      });
    }

    return this.aggregateCheckResults(checks);
  }

  /**
   * Windows环境特殊合规检查
   */
  private async checkWindowsCompliance(files: string[]) {
    const checks = [
      await this.checkPathHandling(files), // 路径处理检查
      await this.checkPowerShellCompatibility(files), // PowerShell兼容性
      await this.checkFileEncoding(files), // 文件编码检查
      await this.checkLineEndings(files) // 换行符检查
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * 质量门禁验证
   */
  private validateOverallCompliance(results: any): ComplianceResult {
    const allChecks = Object.values(results).flat();
    const failures = allChecks.filter((check: any) => !check.passed);

    return {
      passed: failures.length === 0,
      totalChecks: allChecks.length,
      passedChecks: allChecks.length - failures.length,
      failures: failures.map((f: any) => f.message || f.name),
      timestamp: new Date().toISOString()
    };
  }
}
```

## ⚠️ Windows环境约束

### 禁止事项
- ❌ 使用Linux专用命令和语法
- ❌ 硬编码Unix路径分隔符
- ❌ 忽略Windows文件路径长度限制
- ❌ 不处理Windows权限特殊性
- ❌ 使用不兼容PowerShell的脚本语法

### 最佳实践
- ✅ 使用PowerShell作为默认Shell
- ✅ 使用跨平台的路径处理函数
- ✅ 正确处理Windows长路径问题
- ✅ 考虑Windows防火墙和权限设置
- ✅ 使用Windows兼容的文件编码

---

**参考文档**:
- [开发工作流程增强钩子](.kiro/hooks/development-workflow-enhancement.kiro.hook)
- [项目标准合规钩子](.kiro/hooks/project-standards-compliance.kiro.hook)
- [工作质量保证钩子](.kiro/hooks/work-quality-assurance.kiro.hook)
# ZK-Agent Windows环境与开发钩子工作流程规范

## 📋 Windows环境特殊要求

基于 [开发工作流程增强钩子](.kiro/hooks/development-workflow-enhancement.kiro.hook) 和 [项目标准合规钩子](.kiro/hooks/project-standards-compliance.kiro.hook)，确保Windows环境下的开发规范性。

### 系统环境要求
- **操作系统**: Windows 10/11 (64位)
- **Shell环境**: PowerShell 5.1+ 或 PowerShell Core 7+
- **包管理**: npm/yarn + pip + conda (可选)
- **容器环境**: Docker Desktop for Windows

### PowerShell脚本规范
```powershell
# ✅ 正确的PowerShell脚本示例
param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectPath,

    [Parameter(Mandatory=$false)]
    [switch]$Force
)

# 错误处理设置
$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# 函数定义
function Test-ProjectStructure {
    <#
    .SYNOPSIS
    检查项目结构是否符合规范

    .DESCRIPTION
    验证项目目录结构、配置文件存在性、依赖完整性

    .PARAMETER Path
    项目根目录路径

    .EXAMPLE
    Test-ProjectStructure -Path "E:\zk-agent"
    #>
    param([string]$Path)

    try {
        # 检查必要目录
        $RequiredDirs = @("app", "components", "lib", "backend", "tests")
        foreach ($dir in $RequiredDirs) {
            $dirPath = Join-Path $Path $dir
            if (-not (Test-Path $dirPath)) {
                throw "缺少必要目录: $dir"
            }
        }

        # 检查配置文件
        $RequiredFiles = @("package.json", "tsconfig.json", "tailwind.config.ts")
        foreach ($file in $RequiredFiles) {
            $filePath = Join-Path $Path $file
            if (-not (Test-Path $filePath)) {
                throw "缺少必要文件: $file"
            }
        }

        Write-Output "✅ 项目结构检查通过"
        return $true
    }
    catch {
        Write-Error "❌ 项目结构检查失败: $_"
        return $false
    }
}

# 主执行逻辑
try {
    Write-Output "🔍 开始检查项目: $ProjectPath"

    if (-not (Test-Path $ProjectPath)) {
        throw "项目路径不存在: $ProjectPath"
    }

    $result = Test-ProjectStructure -Path $ProjectPath

    if ($result) {
        Write-Output "🎉 项目检查完成"
        exit 0
    } else {
        exit 1
    }
}
catch {
    Write-Error "💥 执行失败: $_"
    exit 1
}
```

### 路径处理规范
```typescript
// ✅ 正确的跨平台路径处理
import path from 'path';
import os from 'os';
import fs from 'fs/promises';

// 路径处理工具类
export class WindowsPathUtils {
  /**
   * 标准化路径分隔符
   */
  static normalizePath(inputPath: string): string {
    return path.normalize(inputPath).replace(/\\/g, '/');
  }

  /**
   * 获取安全的文件路径
   */
  static getSafeFilePath(basePath: string, fileName: string): string {
    const safeName = fileName.replace(/[<>:"|?*]/g, '_');
    return path.join(basePath, safeName);
  }

  /**
   * 检查路径是否存在且可访问
   */
  static async isAccessible(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath, fs.constants.F_OK | fs.constants.R_OK);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 创建目录（如果不存在）
   */
  static async ensureDirectory(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error: any) {
      if (error.code !== 'EEXIST') {
        throw new Error(`创建目录失败: ${dirPath}, 错误: ${error.message}`);
      }
    }
  }

  /**
   * 获取临时目录路径
   */
  static getTempPath(): string {
    return os.tmpdir();
  }

  /**
   * 处理Windows长路径问题
   */
  static handleLongPath(inputPath: string): string {
    if (process.platform === 'win32' && inputPath.length > 260) {
      return `\\\\?\\${path.resolve(inputPath)}`;
    }
    return inputPath;
  }
}
```

## 🔄 开发工作流程增强钩子

### 工作前分析流程
基于 [开发工作流程增强钩子](.kiro/hooks/development-workflow-enhancement.kiro.hook)，每次文件编辑时自动触发全面分析。

```typescript
// 自动触发文件模式
const TRIGGER_PATTERNS = [
  "**/*.py", "**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx",
  "**/*.vue", "**/*.md", "requirements.txt", "package.json",
  "pyproject.toml", "Dockerfile", "docker-compose.yml",
  ".env*", "config/**/*", "docs/**/*", "tests/**/*"
];

interface WorkflowAnalysis {
  // 阶段1：工作前质量保证分析
  mcpToolsAvailability: {
    serena: boolean;
    zen: boolean;
    memory: boolean;
    sequentialThinking: boolean;
    context7: boolean;
    time: boolean;
    git: boolean;
    fetch: boolean;
  };

  // 历史经验复用
  historicalLessons: {
    searchResults: any[];
    applicablePatterns: string[];
    riskPreventionMeasures: string[];
  };

  // 全局架构一致性
  architectureConsistency: {
    analyzisResult: any;
    moduleBoundaryCheck: boolean;
    dependencyValidation: boolean;
    complianceScore: number;
  };

  // 代码冗余检查
  redundancyValidation: {
    duplicateCodeCheck: any;
    similarModulesFound: string[];
    documentationConsistency: boolean;
  };
}
```

### 强制检查点实现
```typescript
// ✅ 工作前强制检查流程
export class WorkflowEnhancementChecker {
  private mcpTools: MCPToolsManager;
  private memoryStore: MemoryStore;
  private codeAnalyzer: CodeAnalyzer;

  constructor() {
    this.mcpTools = new MCPToolsManager();
    this.memoryStore = new MemoryStore();
    this.codeAnalyzer = new CodeAnalyzer();
  }

  /**
   * 执行完整的工作前分析
   */
  async executePreWorkAnalysis(changedFiles: string[]): Promise<WorkflowAnalysis> {
    console.log("🚀 开始执行开发工作流程增强分析...");

    // 阶段1：MCP工具可用性检查
    const mcpAvailability = await this.checkMCPToolsAvailability();
    if (!this.validateMCPToolsReady(mcpAvailability)) {
      throw new Error("MCP工具未就绪，无法继续工作");
    }

    // 阶段2：历史经验与风险预防
    const historicalData = await this.analyzeHistoricalLessons(changedFiles);

    // 阶段3：架构一致性检查
    const architectureCheck = await this.validateArchitectureConsistency(changedFiles);

    // 阶段4：冗余检查
    const redundancyCheck = await this.validateRedundancy(changedFiles);

    // 阶段5：异常状态检查
    await this.checkSystemAnomalies();

    const analysis: WorkflowAnalysis = {
      mcpToolsAvailability: mcpAvailability,
      historicalLessons: historicalData,
      architectureConsistency: architectureCheck,
      redundancyValidation: redundancyCheck
    };

    // 生成详细评估报告
    await this.generateAssessmentReport(analysis);

    console.log("✅ 工作前分析完成，可以开始开发工作");
    return analysis;
  }

  /**
   * 检查MCP工具可用性
   */
  private async checkMCPToolsAvailability() {
    const tools = {
      serena: await this.mcpTools.isSerenaAvailable(),
      zen: await this.mcpTools.isZenAvailable(),
      memory: await this.mcpTools.isMemoryAvailable(),
      sequentialThinking: await this.mcpTools.isSequentialThinkingAvailable(),
      context7: await this.mcpTools.isContext7Available(),
      time: await this.mcpTools.isTimeAvailable(),
      git: await this.mcpTools.isGitAvailable(),
      fetch: await this.mcpTools.isFetchAvailable()
    };

    console.log("🔍 MCP工具可用性检查:", tools);
    return tools;
  }

  /**
   * 验证MCP工具就绪状态
   */
  private validateMCPToolsReady(availability: any): boolean {
    const requiredTools = ['serena', 'memory', 'sequentialThinking'];
    const unavailableTools = requiredTools.filter(tool => !availability[tool]);

    if (unavailableTools.length > 0) {
      console.error(`❌ 必需的MCP工具不可用: ${unavailableTools.join(', ')}`);
      return false;
    }

    return true;
  }

  /**
   * 分析历史经验和教训
   */
  private async analyzeHistoricalLessons(files: string[]) {
    // 使用memory.search_nodes()查询相关历史经验
    const searchResults = await this.memoryStore.searchNodes({
      patterns: files.map(f => path.extname(f)),
      context: "development_experience",
      limit: 10
    });

    // 分析可复用模式
    const applicablePatterns = await this.memoryStore.findApplicablePatterns({
      currentFiles: files,
      searchResults: searchResults
    });

    // 制定风险预防措施
    const riskMeasures = await this.memoryStore.getRiskPreventionMeasures({
      patterns: applicablePatterns,
      context: "file_modification"
    });

    return {
      searchResults,
      applicablePatterns,
      riskPreventionMeasures: riskMeasures
    };
  }

  /**
   * 验证架构一致性
   */
  private async validateArchitectureConsistency(files: string[]) {
    // 使用serena.architecture_analyze()分析架构
    const analysisResult = await this.mcpTools.serena.architectureAnalyze(files);

    // 检查模块边界
    const moduleBoundaryCheck = await this.codeAnalyzer.validateModuleBoundaries(files);

    // 验证依赖关系
    const dependencyValidation = await this.codeAnalyzer.validateDependencies(files);

    // 计算合规评分
    const complianceScore = this.calculateComplianceScore({
      analysisResult,
      moduleBoundaryCheck,
      dependencyValidation
    });

    if (complianceScore < 90) {
      console.warn(`⚠️ 架构合规性评分较低: ${complianceScore}/100`);
    }

    return {
      analysisResult,
      moduleBoundaryCheck,
      dependencyValidation,
      complianceScore
    };
  }

  /**
   * 验证代码和文档冗余
   */
  private async validateRedundancy(files: string[]) {
    // 使用serena.duplicate_check()检测重复代码
    const duplicateCheck = await this.mcpTools.serena.duplicateCheck(files);

    // 搜索类似功能模块
    const similarModules = await this.codeAnalyzer.findSimilarModules(files);

    // 验证文档一致性
    const docConsistency = await this.codeAnalyzer.validateDocumentationConsistency();

    if (duplicateCheck.duplicates.length > 0) {
      console.warn(`⚠️ 发现重复代码: ${duplicateCheck.duplicates.length}处`);
    }

    return {
      duplicateCodeCheck: duplicateCheck,
      similarModulesFound: similarModules,
      documentationConsistency: docConsistency
    };
  }

  /**
   * 检查系统异常状态
   */
  private async checkSystemAnomalies() {
    // 检查上次工作遗留问题
    const pendingIssues = await this.memoryStore.getPendingIssues();

    // 验证系统运行状态
    const systemStatus = await this.checkSystemStatus();

    // 确认开发环境配置
    const envValidation = await this.validateEnvironmentConfig();

    if (pendingIssues.length > 0) {
      console.warn(`⚠️ 发现${pendingIssues.length}个遗留问题需要处理`);
    }

    if (!systemStatus.healthy) {
      throw new Error(`系统状态异常: ${systemStatus.issues.join(', ')}`);
    }

    if (!envValidation.valid) {
      throw new Error(`环境配置异常: ${envValidation.errors.join(', ')}`);
    }
  }

  /**
   * 生成评估报告
   */
  private async generateAssessmentReport(analysis: WorkflowAnalysis) {
    const report = {
      timestamp: new Date().toISOString(),
      mcpToolsStatus: analysis.mcpToolsAvailability,
      historicalInsights: analysis.historicalLessons.applicablePatterns,
      architectureScore: analysis.architectureConsistency.complianceScore,
      redundancyIssues: analysis.redundancyValidation.duplicateCodeCheck.duplicates.length,
      recommendations: this.generateRecommendations(analysis),
      readyToProceed: this.isReadyToProceed(analysis)
    };

    // 存储到memory
    await this.memoryStore.storeAssessmentReport(report);

    console.log("📊 评估报告已生成并存储");
    return report;
  }

  /**
   * 生成改进建议
   */
  private generateRecommendations(analysis: WorkflowAnalysis): string[] {
    const recommendations: string[] = [];

    if (analysis.architectureConsistency.complianceScore < 90) {
      recommendations.push("建议优化架构设计，提高合规性评分");
    }

    if (analysis.redundancyValidation.duplicateCodeCheck.duplicates.length > 0) {
      recommendations.push("建议重构重复代码，提高代码复用性");
    }

    if (analysis.redundancyValidation.similarModulesFound.length > 0) {
      recommendations.push("发现相似模块，建议合并或抽象公共功能");
    }

    return recommendations;
  }

  /**
   * 判断是否准备好继续工作
   */
  private isReadyToProceed(analysis: WorkflowAnalysis): boolean {
    // 检查阻塞条件
    const blockingIssues = [
      analysis.architectureConsistency.complianceScore < 80,
      !analysis.architectureConsistency.moduleBoundaryCheck,
      !analysis.redundancyValidation.documentationConsistency
    ];

    return !blockingIssues.some(issue => issue);
  }
}
```

## 📋 项目标准合规检查钩子

### 提交前强制检查
基于 [项目标准合规钩子](.kiro/hooks/project-standards-compliance.kiro.hook)，在每次提交前自动执行全面的合规检查。

```typescript
// 自动触发：beforeCommit事件，匹配所有文件
export class ProjectStandardsComplianceChecker {
  private serena: SerenaTools;
  private qualityGates: QualityGates;

  /**
   * 执行完整的项目规范遵循检查
   */
  async executeComplianceCheck(files: string[]): Promise<ComplianceResult> {
    console.log("📋 开始执行项目规范遵循检查...");

    const results = {
      pythonCompliance: await this.checkPythonCompliance(files),
      typescriptCompliance: await this.checkTypescriptCompliance(files),
      documentationCompliance: await this.checkDocumentationCompliance(files),
      testingCompliance: await this.checkTestingCompliance(files),
      securityCompliance: await this.checkSecurityCompliance(files),
      performanceCompliance: await this.checkPerformanceCompliance(files),
      structureCompliance: await this.checkStructureCompliance(files),
      versionControlCompliance: await this.checkVersionControlCompliance(files),
      windowsCompliance: await this.checkWindowsCompliance(files)
    };

    // 验证所有检查都通过
    const overallResult = this.validateOverallCompliance(results);

    if (!overallResult.passed) {
      throw new Error(`合规检查失败: ${overallResult.failures.join(', ')}`);
    }

    console.log("✅ 所有项目规范遵循检查通过");
    return overallResult;
  }

  /**
   * Python开发规范检查
   */
  private async checkPythonCompliance(files: string[]) {
    const pythonFiles = files.filter(f => f.endsWith('.py'));
    if (pythonFiles.length === 0) return { passed: true, issues: [] };

    const checks = [
      await this.serena.styleCheck(pythonFiles), // PEP 8检查
      await this.serena.complexityCheck(pythonFiles), // 复杂度检查
      await this.checkTypeAnnotations(pythonFiles), // 类型注解检查
      await this.checkAsyncUsage(pythonFiles), // 异步编程检查
      await this.checkExceptionHandling(pythonFiles), // 异常处理检查
      await this.checkLoggingUsage(pythonFiles) // 日志使用检查
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * TypeScript开发规范检查
   */
  private async checkTypescriptCompliance(files: string[]) {
    const tsFiles = files.filter(f => f.match(/\.(ts|tsx)$/));
    if (tsFiles.length === 0) return { passed: true, issues: [] };

    const checks = [
      await this.serena.styleCheck(tsFiles), // ESLint检查
      await this.checkStrictMode(tsFiles), // 严格模式检查
      await this.checkTypeDefinitions(tsFiles), // 类型定义检查
      await this.checkComponentStructure(tsFiles), // 组件结构检查
      await this.checkImportOrganization(tsFiles) // 导入组织检查
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * 测试规范合规检查
   */
  private async checkTestingCompliance(files: string[]) {
    const coverage = await this.serena.testCoverage(files);
    const testFiles = files.filter(f => f.match(/\.(test|spec)\.(ts|tsx|py)$/));

    const checks = [
      {
        name: "测试覆盖率检查",
        passed: coverage.percentage >= 85,
        message: `测试覆盖率: ${coverage.percentage}% (要求≥85%)`
      },
      {
        name: "测试文件存在性检查",
        passed: testFiles.length > 0 || files.length === 0,
        message: testFiles.length === 0 ? "没有找到测试文件" : "找到测试文件"
      }
    ];

    // 运行测试
    if (testFiles.length > 0) {
      const testResult = await this.serena.testRun(testFiles);
      checks.push({
        name: "测试执行检查",
        passed: testResult.success,
        message: testResult.success ? "所有测试通过" : `${testResult.failedCount}个测试失败`
      });
    }

    return this.aggregateCheckResults(checks);
  }

  /**
   * 安全规范合规检查
   */
  private async checkSecurityCompliance(files: string[]) {
    const checks = [
      await this.serena.securityScan(files), // 安全漏洞扫描
      await this.serena.secretScan(files), // 敏感信息扫描
      await this.serena.dependencyCheck(files), // 依赖安全检查
      await this.serena.permissionCheck(files) // 权限检查
    ];

    // 验证无高危漏洞
    const securityScan = checks[0];
    const highRiskVulns = securityScan.vulnerabilities?.filter(v => v.severity === 'high') || [];

    if (highRiskVulns.length > 0) {
      checks.push({
        name: "高危漏洞检查",
        passed: false,
        message: `发现${highRiskVulns.length}个高危安全漏洞`
      });
    }

    return this.aggregateCheckResults(checks);
  }

  /**
   * Windows环境特殊合规检查
   */
  private async checkWindowsCompliance(files: string[]) {
    const checks = [
      await this.checkPathHandling(files), // 路径处理检查
      await this.checkPowerShellCompatibility(files), // PowerShell兼容性
      await this.checkFileEncoding(files), // 文件编码检查
      await this.checkLineEndings(files) // 换行符检查
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * 质量门禁验证
   */
  private validateOverallCompliance(results: any): ComplianceResult {
    const allChecks = Object.values(results).flat();
    const failures = allChecks.filter((check: any) => !check.passed);

    return {
      passed: failures.length === 0,
      totalChecks: allChecks.length,
      passedChecks: allChecks.length - failures.length,
      failures: failures.map((f: any) => f.message || f.name),
      timestamp: new Date().toISOString()
    };
  }
}
```

## ⚠️ Windows环境约束

### 禁止事项
- ❌ 使用Linux专用命令和语法
- ❌ 硬编码Unix路径分隔符
- ❌ 忽略Windows文件路径长度限制
- ❌ 不处理Windows权限特殊性
- ❌ 使用不兼容PowerShell的脚本语法

### 最佳实践
- ✅ 使用PowerShell作为默认Shell
- ✅ 使用跨平台的路径处理函数
- ✅ 正确处理Windows长路径问题
- ✅ 考虑Windows防火墙和权限设置
- ✅ 使用Windows兼容的文件编码

---

**参考文档**:
- [开发工作流程增强钩子](.kiro/hooks/development-workflow-enhancement.kiro.hook)
- [项目标准合规钩子](.kiro/hooks/project-standards-compliance.kiro.hook)
- [工作质量保证钩子](.kiro/hooks/work-quality-assurance.kiro.hook)
