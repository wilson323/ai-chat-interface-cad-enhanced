---
alwaysApply: true
---

# ZK-Agent Windowsç¯å¢ƒä¸å¼€å‘é’©å­å·¥ä½œæµç¨‹è§„èŒƒ

## ğŸ“‹ Windowsç¯å¢ƒç‰¹æ®Šè¦æ±‚

åŸºäº [å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­](.kiro/hooks/development-workflow-enhancement.kiro.hook) å’Œ [é¡¹ç›®æ ‡å‡†åˆè§„é’©å­](.kiro/hooks/project-standards-compliance.kiro.hook)ï¼Œç¡®ä¿Windowsç¯å¢ƒä¸‹çš„å¼€å‘è§„èŒƒæ€§ã€‚

### ç³»ç»Ÿç¯å¢ƒè¦æ±‚
- **æ“ä½œç³»ç»Ÿ**: Windows 10/11 (64ä½)
- **Shellç¯å¢ƒ**: PowerShell 5.1+ æˆ– PowerShell Core 7+
- **åŒ…ç®¡ç†**: npm/yarn + pip + conda (å¯é€‰)
- **å®¹å™¨ç¯å¢ƒ**: Docker Desktop for Windows

### PowerShellè„šæœ¬è§„èŒƒ
```powershell
# âœ… æ­£ç¡®çš„PowerShellè„šæœ¬ç¤ºä¾‹
param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectPath,

    [Parameter(Mandatory=$false)]
    [switch]$Force
)

# é”™è¯¯å¤„ç†è®¾ç½®
$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# å‡½æ•°å®šä¹‰
function Test-ProjectStructure {
    <#
    .SYNOPSIS
    æ£€æŸ¥é¡¹ç›®ç»“æ„æ˜¯å¦ç¬¦åˆè§„èŒƒ

    .DESCRIPTION
    éªŒè¯é¡¹ç›®ç›®å½•ç»“æ„ã€é…ç½®æ–‡ä»¶å­˜åœ¨æ€§ã€ä¾èµ–å®Œæ•´æ€§

    .PARAMETER Path
    é¡¹ç›®æ ¹ç›®å½•è·¯å¾„

    .EXAMPLE
    Test-ProjectStructure -Path "E:\zk-agent"
    #>
    param([string]$Path)

    try {
        # æ£€æŸ¥å¿…è¦ç›®å½•
        $RequiredDirs = @("app", "components", "lib", "backend", "tests")
        foreach ($dir in $RequiredDirs) {
            $dirPath = Join-Path $Path $dir
            if (-not (Test-Path $dirPath)) {
                throw "ç¼ºå°‘å¿…è¦ç›®å½•: $dir"
            }
        }

        # æ£€æŸ¥é…ç½®æ–‡ä»¶
        $RequiredFiles = @("package.json", "tsconfig.json", "tailwind.config.ts")
        foreach ($file in $RequiredFiles) {
            $filePath = Join-Path $Path $file
            if (-not (Test-Path $filePath)) {
                throw "ç¼ºå°‘å¿…è¦æ–‡ä»¶: $file"
            }
        }

        Write-Output "âœ… é¡¹ç›®ç»“æ„æ£€æŸ¥é€šè¿‡"
        return $true
    }
    catch {
        Write-Error "âŒ é¡¹ç›®ç»“æ„æ£€æŸ¥å¤±è´¥: $_"
        return $false
    }
}

# ä¸»æ‰§è¡Œé€»è¾‘
try {
    Write-Output "ğŸ” å¼€å§‹æ£€æŸ¥é¡¹ç›®: $ProjectPath"

    if (-not (Test-Path $ProjectPath)) {
        throw "é¡¹ç›®è·¯å¾„ä¸å­˜åœ¨: $ProjectPath"
    }

    $result = Test-ProjectStructure -Path $ProjectPath

    if ($result) {
        Write-Output "ğŸ‰ é¡¹ç›®æ£€æŸ¥å®Œæˆ"
        exit 0
    } else {
        exit 1
    }
}
catch {
    Write-Error "ğŸ’¥ æ‰§è¡Œå¤±è´¥: $_"
    exit 1
}
```

### è·¯å¾„å¤„ç†è§„èŒƒ
```typescript
// âœ… æ­£ç¡®çš„è·¨å¹³å°è·¯å¾„å¤„ç†
import path from 'path';
import os from 'os';
import fs from 'fs/promises';

// è·¯å¾„å¤„ç†å·¥å…·ç±»
export class WindowsPathUtils {
  /**
   * æ ‡å‡†åŒ–è·¯å¾„åˆ†éš”ç¬¦
   */
  static normalizePath(inputPath: string): string {
    return path.normalize(inputPath).replace(/\\/g, '/');
  }

  /**
   * è·å–å®‰å…¨çš„æ–‡ä»¶è·¯å¾„
   */
  static getSafeFilePath(basePath: string, fileName: string): string {
    const safeName = fileName.replace(/[<>:"|?*]/g, '_');
    return path.join(basePath, safeName);
  }

  /**
   * æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨ä¸”å¯è®¿é—®
   */
  static async isAccessible(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath, fs.constants.F_OK | fs.constants.R_OK);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * åˆ›å»ºç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
   */
  static async ensureDirectory(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error: any) {
      if (error.code !== 'EEXIST') {
        throw new Error(`åˆ›å»ºç›®å½•å¤±è´¥: ${dirPath}, é”™è¯¯: ${error.message}`);
      }
    }
  }

  /**
   * è·å–ä¸´æ—¶ç›®å½•è·¯å¾„
   */
  static getTempPath(): string {
    return os.tmpdir();
  }

  /**
   * å¤„ç†Windowsé•¿è·¯å¾„é—®é¢˜
   */
  static handleLongPath(inputPath: string): string {
    if (process.platform === 'win32' && inputPath.length > 260) {
      return `\\\\?\\${path.resolve(inputPath)}`;
    }
    return inputPath;
  }
}
```

## ğŸ”„ å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­

### å·¥ä½œå‰åˆ†ææµç¨‹
åŸºäº [å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­](.kiro/hooks/development-workflow-enhancement.kiro.hook)ï¼Œæ¯æ¬¡æ–‡ä»¶ç¼–è¾‘æ—¶è‡ªåŠ¨è§¦å‘å…¨é¢åˆ†æã€‚

```typescript
// è‡ªåŠ¨è§¦å‘æ–‡ä»¶æ¨¡å¼
const TRIGGER_PATTERNS = [
  "**/*.py", "**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx",
  "**/*.vue", "**/*.md", "requirements.txt", "package.json",
  "pyproject.toml", "Dockerfile", "docker-compose.yml",
  ".env*", "config/**/*", "docs/**/*", "tests/**/*"
];

interface WorkflowAnalysis {
  // é˜¶æ®µ1ï¼šå·¥ä½œå‰è´¨é‡ä¿è¯åˆ†æ
  mcpToolsAvailability: {
    serena: boolean;
    zen: boolean;
    memory: boolean;
    sequentialThinking: boolean;
    context7: boolean;
    time: boolean;
    git: boolean;
    fetch: boolean;
  };

  // å†å²ç»éªŒå¤ç”¨
  historicalLessons: {
    searchResults: any[];
    applicablePatterns: string[];
    riskPreventionMeasures: string[];
  };

  // å…¨å±€æ¶æ„ä¸€è‡´æ€§
  architectureConsistency: {
    analyzisResult: any;
    moduleBoundaryCheck: boolean;
    dependencyValidation: boolean;
    complianceScore: number;
  };

  // ä»£ç å†—ä½™æ£€æŸ¥
  redundancyValidation: {
    duplicateCodeCheck: any;
    similarModulesFound: string[];
    documentationConsistency: boolean;
  };
}
```

### å¼ºåˆ¶æ£€æŸ¥ç‚¹å®ç°
```typescript
// âœ… å·¥ä½œå‰å¼ºåˆ¶æ£€æŸ¥æµç¨‹
export class WorkflowEnhancementChecker {
  private mcpTools: MCPToolsManager;
  private memoryStore: MemoryStore;
  private codeAnalyzer: CodeAnalyzer;

  constructor() {
    this.mcpTools = new MCPToolsManager();
    this.memoryStore = new MemoryStore();
    this.codeAnalyzer = new CodeAnalyzer();
  }

  /**
   * æ‰§è¡Œå®Œæ•´çš„å·¥ä½œå‰åˆ†æ
   */
  async executePreWorkAnalysis(changedFiles: string[]): Promise<WorkflowAnalysis> {
    console.log("ğŸš€ å¼€å§‹æ‰§è¡Œå¼€å‘å·¥ä½œæµç¨‹å¢å¼ºåˆ†æ...");

    // é˜¶æ®µ1ï¼šMCPå·¥å…·å¯ç”¨æ€§æ£€æŸ¥
    const mcpAvailability = await this.checkMCPToolsAvailability();
    if (!this.validateMCPToolsReady(mcpAvailability)) {
      throw new Error("MCPå·¥å…·æœªå°±ç»ªï¼Œæ— æ³•ç»§ç»­å·¥ä½œ");
    }

    // é˜¶æ®µ2ï¼šå†å²ç»éªŒä¸é£é™©é¢„é˜²
    const historicalData = await this.analyzeHistoricalLessons(changedFiles);

    // é˜¶æ®µ3ï¼šæ¶æ„ä¸€è‡´æ€§æ£€æŸ¥
    const architectureCheck = await this.validateArchitectureConsistency(changedFiles);

    // é˜¶æ®µ4ï¼šå†—ä½™æ£€æŸ¥
    const redundancyCheck = await this.validateRedundancy(changedFiles);

    // é˜¶æ®µ5ï¼šå¼‚å¸¸çŠ¶æ€æ£€æŸ¥
    await this.checkSystemAnomalies();

    const analysis: WorkflowAnalysis = {
      mcpToolsAvailability: mcpAvailability,
      historicalLessons: historicalData,
      architectureConsistency: architectureCheck,
      redundancyValidation: redundancyCheck
    };

    // ç”Ÿæˆè¯¦ç»†è¯„ä¼°æŠ¥å‘Š
    await this.generateAssessmentReport(analysis);

    console.log("âœ… å·¥ä½œå‰åˆ†æå®Œæˆï¼Œå¯ä»¥å¼€å§‹å¼€å‘å·¥ä½œ");
    return analysis;
  }

  /**
   * æ£€æŸ¥MCPå·¥å…·å¯ç”¨æ€§
   */
  private async checkMCPToolsAvailability() {
    const tools = {
      serena: await this.mcpTools.isSerenaAvailable(),
      zen: await this.mcpTools.isZenAvailable(),
      memory: await this.mcpTools.isMemoryAvailable(),
      sequentialThinking: await this.mcpTools.isSequentialThinkingAvailable(),
      context7: await this.mcpTools.isContext7Available(),
      time: await this.mcpTools.isTimeAvailable(),
      git: await this.mcpTools.isGitAvailable(),
      fetch: await this.mcpTools.isFetchAvailable()
    };

    console.log("ğŸ” MCPå·¥å…·å¯ç”¨æ€§æ£€æŸ¥:", tools);
    return tools;
  }

  /**
   * éªŒè¯MCPå·¥å…·å°±ç»ªçŠ¶æ€
   */
  private validateMCPToolsReady(availability: any): boolean {
    const requiredTools = ['serena', 'memory', 'sequentialThinking'];
    const unavailableTools = requiredTools.filter(tool => !availability[tool]);

    if (unavailableTools.length > 0) {
      console.error(`âŒ å¿…éœ€çš„MCPå·¥å…·ä¸å¯ç”¨: ${unavailableTools.join(', ')}`);
      return false;
    }

    return true;
  }

  /**
   * åˆ†æå†å²ç»éªŒå’Œæ•™è®­
   */
  private async analyzeHistoricalLessons(files: string[]) {
    // ä½¿ç”¨memory.search_nodes()æŸ¥è¯¢ç›¸å…³å†å²ç»éªŒ
    const searchResults = await this.memoryStore.searchNodes({
      patterns: files.map(f => path.extname(f)),
      context: "development_experience",
      limit: 10
    });

    // åˆ†æå¯å¤ç”¨æ¨¡å¼
    const applicablePatterns = await this.memoryStore.findApplicablePatterns({
      currentFiles: files,
      searchResults: searchResults
    });

    // åˆ¶å®šé£é™©é¢„é˜²æªæ–½
    const riskMeasures = await this.memoryStore.getRiskPreventionMeasures({
      patterns: applicablePatterns,
      context: "file_modification"
    });

    return {
      searchResults,
      applicablePatterns,
      riskPreventionMeasures: riskMeasures
    };
  }

  /**
   * éªŒè¯æ¶æ„ä¸€è‡´æ€§
   */
  private async validateArchitectureConsistency(files: string[]) {
    // ä½¿ç”¨serena.architecture_analyze()åˆ†ææ¶æ„
    const analysisResult = await this.mcpTools.serena.architectureAnalyze(files);

    // æ£€æŸ¥æ¨¡å—è¾¹ç•Œ
    const moduleBoundaryCheck = await this.codeAnalyzer.validateModuleBoundaries(files);

    // éªŒè¯ä¾èµ–å…³ç³»
    const dependencyValidation = await this.codeAnalyzer.validateDependencies(files);

    // è®¡ç®—åˆè§„è¯„åˆ†
    const complianceScore = this.calculateComplianceScore({
      analysisResult,
      moduleBoundaryCheck,
      dependencyValidation
    });

    if (complianceScore < 90) {
      console.warn(`âš ï¸ æ¶æ„åˆè§„æ€§è¯„åˆ†è¾ƒä½: ${complianceScore}/100`);
    }

    return {
      analysisResult,
      moduleBoundaryCheck,
      dependencyValidation,
      complianceScore
    };
  }

  /**
   * éªŒè¯ä»£ç å’Œæ–‡æ¡£å†—ä½™
   */
  private async validateRedundancy(files: string[]) {
    // ä½¿ç”¨serena.duplicate_check()æ£€æµ‹é‡å¤ä»£ç 
    const duplicateCheck = await this.mcpTools.serena.duplicateCheck(files);

    // æœç´¢ç±»ä¼¼åŠŸèƒ½æ¨¡å—
    const similarModules = await this.codeAnalyzer.findSimilarModules(files);

    // éªŒè¯æ–‡æ¡£ä¸€è‡´æ€§
    const docConsistency = await this.codeAnalyzer.validateDocumentationConsistency();

    if (duplicateCheck.duplicates.length > 0) {
      console.warn(`âš ï¸ å‘ç°é‡å¤ä»£ç : ${duplicateCheck.duplicates.length}å¤„`);
    }

    return {
      duplicateCodeCheck: duplicateCheck,
      similarModulesFound: similarModules,
      documentationConsistency: docConsistency
    };
  }

  /**
   * æ£€æŸ¥ç³»ç»Ÿå¼‚å¸¸çŠ¶æ€
   */
  private async checkSystemAnomalies() {
    // æ£€æŸ¥ä¸Šæ¬¡å·¥ä½œé—ç•™é—®é¢˜
    const pendingIssues = await this.memoryStore.getPendingIssues();

    // éªŒè¯ç³»ç»Ÿè¿è¡ŒçŠ¶æ€
    const systemStatus = await this.checkSystemStatus();

    // ç¡®è®¤å¼€å‘ç¯å¢ƒé…ç½®
    const envValidation = await this.validateEnvironmentConfig();

    if (pendingIssues.length > 0) {
      console.warn(`âš ï¸ å‘ç°${pendingIssues.length}ä¸ªé—ç•™é—®é¢˜éœ€è¦å¤„ç†`);
    }

    if (!systemStatus.healthy) {
      throw new Error(`ç³»ç»ŸçŠ¶æ€å¼‚å¸¸: ${systemStatus.issues.join(', ')}`);
    }

    if (!envValidation.valid) {
      throw new Error(`ç¯å¢ƒé…ç½®å¼‚å¸¸: ${envValidation.errors.join(', ')}`);
    }
  }

  /**
   * ç”Ÿæˆè¯„ä¼°æŠ¥å‘Š
   */
  private async generateAssessmentReport(analysis: WorkflowAnalysis) {
    const report = {
      timestamp: new Date().toISOString(),
      mcpToolsStatus: analysis.mcpToolsAvailability,
      historicalInsights: analysis.historicalLessons.applicablePatterns,
      architectureScore: analysis.architectureConsistency.complianceScore,
      redundancyIssues: analysis.redundancyValidation.duplicateCodeCheck.duplicates.length,
      recommendations: this.generateRecommendations(analysis),
      readyToProceed: this.isReadyToProceed(analysis)
    };

    // å­˜å‚¨åˆ°memory
    await this.memoryStore.storeAssessmentReport(report);

    console.log("ğŸ“Š è¯„ä¼°æŠ¥å‘Šå·²ç”Ÿæˆå¹¶å­˜å‚¨");
    return report;
  }

  /**
   * ç”Ÿæˆæ”¹è¿›å»ºè®®
   */
  private generateRecommendations(analysis: WorkflowAnalysis): string[] {
    const recommendations: string[] = [];

    if (analysis.architectureConsistency.complianceScore < 90) {
      recommendations.push("å»ºè®®ä¼˜åŒ–æ¶æ„è®¾è®¡ï¼Œæé«˜åˆè§„æ€§è¯„åˆ†");
    }

    if (analysis.redundancyValidation.duplicateCodeCheck.duplicates.length > 0) {
      recommendations.push("å»ºè®®é‡æ„é‡å¤ä»£ç ï¼Œæé«˜ä»£ç å¤ç”¨æ€§");
    }

    if (analysis.redundancyValidation.similarModulesFound.length > 0) {
      recommendations.push("å‘ç°ç›¸ä¼¼æ¨¡å—ï¼Œå»ºè®®åˆå¹¶æˆ–æŠ½è±¡å…¬å…±åŠŸèƒ½");
    }

    return recommendations;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦å‡†å¤‡å¥½ç»§ç»­å·¥ä½œ
   */
  private isReadyToProceed(analysis: WorkflowAnalysis): boolean {
    // æ£€æŸ¥é˜»å¡æ¡ä»¶
    const blockingIssues = [
      analysis.architectureConsistency.complianceScore < 80,
      !analysis.architectureConsistency.moduleBoundaryCheck,
      !analysis.redundancyValidation.documentationConsistency
    ];

    return !blockingIssues.some(issue => issue);
  }
}
```

## ğŸ“‹ é¡¹ç›®æ ‡å‡†åˆè§„æ£€æŸ¥é’©å­

### æäº¤å‰å¼ºåˆ¶æ£€æŸ¥
åŸºäº [é¡¹ç›®æ ‡å‡†åˆè§„é’©å­](.kiro/hooks/project-standards-compliance.kiro.hook)ï¼Œåœ¨æ¯æ¬¡æäº¤å‰è‡ªåŠ¨æ‰§è¡Œå…¨é¢çš„åˆè§„æ£€æŸ¥ã€‚

```typescript
// è‡ªåŠ¨è§¦å‘ï¼šbeforeCommitäº‹ä»¶ï¼ŒåŒ¹é…æ‰€æœ‰æ–‡ä»¶
export class ProjectStandardsComplianceChecker {
  private serena: SerenaTools;
  private qualityGates: QualityGates;

  /**
   * æ‰§è¡Œå®Œæ•´çš„é¡¹ç›®è§„èŒƒéµå¾ªæ£€æŸ¥
   */
  async executeComplianceCheck(files: string[]): Promise<ComplianceResult> {
    console.log("ğŸ“‹ å¼€å§‹æ‰§è¡Œé¡¹ç›®è§„èŒƒéµå¾ªæ£€æŸ¥...");

    const results = {
      pythonCompliance: await this.checkPythonCompliance(files),
      typescriptCompliance: await this.checkTypescriptCompliance(files),
      documentationCompliance: await this.checkDocumentationCompliance(files),
      testingCompliance: await this.checkTestingCompliance(files),
      securityCompliance: await this.checkSecurityCompliance(files),
      performanceCompliance: await this.checkPerformanceCompliance(files),
      structureCompliance: await this.checkStructureCompliance(files),
      versionControlCompliance: await this.checkVersionControlCompliance(files),
      windowsCompliance: await this.checkWindowsCompliance(files)
    };

    // éªŒè¯æ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡
    const overallResult = this.validateOverallCompliance(results);

    if (!overallResult.passed) {
      throw new Error(`åˆè§„æ£€æŸ¥å¤±è´¥: ${overallResult.failures.join(', ')}`);
    }

    console.log("âœ… æ‰€æœ‰é¡¹ç›®è§„èŒƒéµå¾ªæ£€æŸ¥é€šè¿‡");
    return overallResult;
  }

  /**
   * Pythonå¼€å‘è§„èŒƒæ£€æŸ¥
   */
  private async checkPythonCompliance(files: string[]) {
    const pythonFiles = files.filter(f => f.endsWith('.py'));
    if (pythonFiles.length === 0) return { passed: true, issues: [] };

    const checks = [
      await this.serena.styleCheck(pythonFiles), // PEP 8æ£€æŸ¥
      await this.serena.complexityCheck(pythonFiles), // å¤æ‚åº¦æ£€æŸ¥
      await this.checkTypeAnnotations(pythonFiles), // ç±»å‹æ³¨è§£æ£€æŸ¥
      await this.checkAsyncUsage(pythonFiles), // å¼‚æ­¥ç¼–ç¨‹æ£€æŸ¥
      await this.checkExceptionHandling(pythonFiles), // å¼‚å¸¸å¤„ç†æ£€æŸ¥
      await this.checkLoggingUsage(pythonFiles) // æ—¥å¿—ä½¿ç”¨æ£€æŸ¥
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * TypeScriptå¼€å‘è§„èŒƒæ£€æŸ¥
   */
  private async checkTypescriptCompliance(files: string[]) {
    const tsFiles = files.filter(f => f.match(/\.(ts|tsx)$/));
    if (tsFiles.length === 0) return { passed: true, issues: [] };

    const checks = [
      await this.serena.styleCheck(tsFiles), // ESLintæ£€æŸ¥
      await this.checkStrictMode(tsFiles), // ä¸¥æ ¼æ¨¡å¼æ£€æŸ¥
      await this.checkTypeDefinitions(tsFiles), // ç±»å‹å®šä¹‰æ£€æŸ¥
      await this.checkComponentStructure(tsFiles), // ç»„ä»¶ç»“æ„æ£€æŸ¥
      await this.checkImportOrganization(tsFiles) // å¯¼å…¥ç»„ç»‡æ£€æŸ¥
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * æµ‹è¯•è§„èŒƒåˆè§„æ£€æŸ¥
   */
  private async checkTestingCompliance(files: string[]) {
    const coverage = await this.serena.testCoverage(files);
    const testFiles = files.filter(f => f.match(/\.(test|spec)\.(ts|tsx|py)$/));

    const checks = [
      {
        name: "æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥",
        passed: coverage.percentage >= 85,
        message: `æµ‹è¯•è¦†ç›–ç‡: ${coverage.percentage}% (è¦æ±‚â‰¥85%)`
      },
      {
        name: "æµ‹è¯•æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥",
        passed: testFiles.length > 0 || files.length === 0,
        message: testFiles.length === 0 ? "æ²¡æœ‰æ‰¾åˆ°æµ‹è¯•æ–‡ä»¶" : "æ‰¾åˆ°æµ‹è¯•æ–‡ä»¶"
      }
    ];

    // è¿è¡Œæµ‹è¯•
    if (testFiles.length > 0) {
      const testResult = await this.serena.testRun(testFiles);
      checks.push({
        name: "æµ‹è¯•æ‰§è¡Œæ£€æŸ¥",
        passed: testResult.success,
        message: testResult.success ? "æ‰€æœ‰æµ‹è¯•é€šè¿‡" : `${testResult.failedCount}ä¸ªæµ‹è¯•å¤±è´¥`
      });
    }

    return this.aggregateCheckResults(checks);
  }

  /**
   * å®‰å…¨è§„èŒƒåˆè§„æ£€æŸ¥
   */
  private async checkSecurityCompliance(files: string[]) {
    const checks = [
      await this.serena.securityScan(files), // å®‰å…¨æ¼æ´æ‰«æ
      await this.serena.secretScan(files), // æ•æ„Ÿä¿¡æ¯æ‰«æ
      await this.serena.dependencyCheck(files), // ä¾èµ–å®‰å…¨æ£€æŸ¥
      await this.serena.permissionCheck(files) // æƒé™æ£€æŸ¥
    ];

    // éªŒè¯æ— é«˜å±æ¼æ´
    const securityScan = checks[0];
    const highRiskVulns = securityScan.vulnerabilities?.filter(v => v.severity === 'high') || [];

    if (highRiskVulns.length > 0) {
      checks.push({
        name: "é«˜å±æ¼æ´æ£€æŸ¥",
        passed: false,
        message: `å‘ç°${highRiskVulns.length}ä¸ªé«˜å±å®‰å…¨æ¼æ´`
      });
    }

    return this.aggregateCheckResults(checks);
  }

  /**
   * Windowsç¯å¢ƒç‰¹æ®Šåˆè§„æ£€æŸ¥
   */
  private async checkWindowsCompliance(files: string[]) {
    const checks = [
      await this.checkPathHandling(files), // è·¯å¾„å¤„ç†æ£€æŸ¥
      await this.checkPowerShellCompatibility(files), // PowerShellå…¼å®¹æ€§
      await this.checkFileEncoding(files), // æ–‡ä»¶ç¼–ç æ£€æŸ¥
      await this.checkLineEndings(files) // æ¢è¡Œç¬¦æ£€æŸ¥
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * è´¨é‡é—¨ç¦éªŒè¯
   */
  private validateOverallCompliance(results: any): ComplianceResult {
    const allChecks = Object.values(results).flat();
    const failures = allChecks.filter((check: any) => !check.passed);

    return {
      passed: failures.length === 0,
      totalChecks: allChecks.length,
      passedChecks: allChecks.length - failures.length,
      failures: failures.map((f: any) => f.message || f.name),
      timestamp: new Date().toISOString()
    };
  }
}
```

## âš ï¸ Windowsç¯å¢ƒçº¦æŸ

### ç¦æ­¢äº‹é¡¹
- âŒ ä½¿ç”¨Linuxä¸“ç”¨å‘½ä»¤å’Œè¯­æ³•
- âŒ ç¡¬ç¼–ç Unixè·¯å¾„åˆ†éš”ç¬¦
- âŒ å¿½ç•¥Windowsæ–‡ä»¶è·¯å¾„é•¿åº¦é™åˆ¶
- âŒ ä¸å¤„ç†Windowsæƒé™ç‰¹æ®Šæ€§
- âŒ ä½¿ç”¨ä¸å…¼å®¹PowerShellçš„è„šæœ¬è¯­æ³•

### æœ€ä½³å®è·µ
- âœ… ä½¿ç”¨PowerShellä½œä¸ºé»˜è®¤Shell
- âœ… ä½¿ç”¨è·¨å¹³å°çš„è·¯å¾„å¤„ç†å‡½æ•°
- âœ… æ­£ç¡®å¤„ç†Windowsé•¿è·¯å¾„é—®é¢˜
- âœ… è€ƒè™‘Windowsé˜²ç«å¢™å’Œæƒé™è®¾ç½®
- âœ… ä½¿ç”¨Windowså…¼å®¹çš„æ–‡ä»¶ç¼–ç 

---

**å‚è€ƒæ–‡æ¡£**:
- [å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­](.kiro/hooks/development-workflow-enhancement.kiro.hook)
- [é¡¹ç›®æ ‡å‡†åˆè§„é’©å­](.kiro/hooks/project-standards-compliance.kiro.hook)
- [å·¥ä½œè´¨é‡ä¿è¯é’©å­](.kiro/hooks/work-quality-assurance.kiro.hook)
# ZK-Agent Windowsç¯å¢ƒä¸å¼€å‘é’©å­å·¥ä½œæµç¨‹è§„èŒƒ

## ğŸ“‹ Windowsç¯å¢ƒç‰¹æ®Šè¦æ±‚

åŸºäº [å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­](.kiro/hooks/development-workflow-enhancement.kiro.hook) å’Œ [é¡¹ç›®æ ‡å‡†åˆè§„é’©å­](.kiro/hooks/project-standards-compliance.kiro.hook)ï¼Œç¡®ä¿Windowsç¯å¢ƒä¸‹çš„å¼€å‘è§„èŒƒæ€§ã€‚

### ç³»ç»Ÿç¯å¢ƒè¦æ±‚
- **æ“ä½œç³»ç»Ÿ**: Windows 10/11 (64ä½)
- **Shellç¯å¢ƒ**: PowerShell 5.1+ æˆ– PowerShell Core 7+
- **åŒ…ç®¡ç†**: npm/yarn + pip + conda (å¯é€‰)
- **å®¹å™¨ç¯å¢ƒ**: Docker Desktop for Windows

### PowerShellè„šæœ¬è§„èŒƒ
```powershell
# âœ… æ­£ç¡®çš„PowerShellè„šæœ¬ç¤ºä¾‹
param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectPath,

    [Parameter(Mandatory=$false)]
    [switch]$Force
)

# é”™è¯¯å¤„ç†è®¾ç½®
$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# å‡½æ•°å®šä¹‰
function Test-ProjectStructure {
    <#
    .SYNOPSIS
    æ£€æŸ¥é¡¹ç›®ç»“æ„æ˜¯å¦ç¬¦åˆè§„èŒƒ

    .DESCRIPTION
    éªŒè¯é¡¹ç›®ç›®å½•ç»“æ„ã€é…ç½®æ–‡ä»¶å­˜åœ¨æ€§ã€ä¾èµ–å®Œæ•´æ€§

    .PARAMETER Path
    é¡¹ç›®æ ¹ç›®å½•è·¯å¾„

    .EXAMPLE
    Test-ProjectStructure -Path "E:\zk-agent"
    #>
    param([string]$Path)

    try {
        # æ£€æŸ¥å¿…è¦ç›®å½•
        $RequiredDirs = @("app", "components", "lib", "backend", "tests")
        foreach ($dir in $RequiredDirs) {
            $dirPath = Join-Path $Path $dir
            if (-not (Test-Path $dirPath)) {
                throw "ç¼ºå°‘å¿…è¦ç›®å½•: $dir"
            }
        }

        # æ£€æŸ¥é…ç½®æ–‡ä»¶
        $RequiredFiles = @("package.json", "tsconfig.json", "tailwind.config.ts")
        foreach ($file in $RequiredFiles) {
            $filePath = Join-Path $Path $file
            if (-not (Test-Path $filePath)) {
                throw "ç¼ºå°‘å¿…è¦æ–‡ä»¶: $file"
            }
        }

        Write-Output "âœ… é¡¹ç›®ç»“æ„æ£€æŸ¥é€šè¿‡"
        return $true
    }
    catch {
        Write-Error "âŒ é¡¹ç›®ç»“æ„æ£€æŸ¥å¤±è´¥: $_"
        return $false
    }
}

# ä¸»æ‰§è¡Œé€»è¾‘
try {
    Write-Output "ğŸ” å¼€å§‹æ£€æŸ¥é¡¹ç›®: $ProjectPath"

    if (-not (Test-Path $ProjectPath)) {
        throw "é¡¹ç›®è·¯å¾„ä¸å­˜åœ¨: $ProjectPath"
    }

    $result = Test-ProjectStructure -Path $ProjectPath

    if ($result) {
        Write-Output "ğŸ‰ é¡¹ç›®æ£€æŸ¥å®Œæˆ"
        exit 0
    } else {
        exit 1
    }
}
catch {
    Write-Error "ğŸ’¥ æ‰§è¡Œå¤±è´¥: $_"
    exit 1
}
```

### è·¯å¾„å¤„ç†è§„èŒƒ
```typescript
// âœ… æ­£ç¡®çš„è·¨å¹³å°è·¯å¾„å¤„ç†
import path from 'path';
import os from 'os';
import fs from 'fs/promises';

// è·¯å¾„å¤„ç†å·¥å…·ç±»
export class WindowsPathUtils {
  /**
   * æ ‡å‡†åŒ–è·¯å¾„åˆ†éš”ç¬¦
   */
  static normalizePath(inputPath: string): string {
    return path.normalize(inputPath).replace(/\\/g, '/');
  }

  /**
   * è·å–å®‰å…¨çš„æ–‡ä»¶è·¯å¾„
   */
  static getSafeFilePath(basePath: string, fileName: string): string {
    const safeName = fileName.replace(/[<>:"|?*]/g, '_');
    return path.join(basePath, safeName);
  }

  /**
   * æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨ä¸”å¯è®¿é—®
   */
  static async isAccessible(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath, fs.constants.F_OK | fs.constants.R_OK);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * åˆ›å»ºç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
   */
  static async ensureDirectory(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error: any) {
      if (error.code !== 'EEXIST') {
        throw new Error(`åˆ›å»ºç›®å½•å¤±è´¥: ${dirPath}, é”™è¯¯: ${error.message}`);
      }
    }
  }

  /**
   * è·å–ä¸´æ—¶ç›®å½•è·¯å¾„
   */
  static getTempPath(): string {
    return os.tmpdir();
  }

  /**
   * å¤„ç†Windowsé•¿è·¯å¾„é—®é¢˜
   */
  static handleLongPath(inputPath: string): string {
    if (process.platform === 'win32' && inputPath.length > 260) {
      return `\\\\?\\${path.resolve(inputPath)}`;
    }
    return inputPath;
  }
}
```

## ğŸ”„ å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­

### å·¥ä½œå‰åˆ†ææµç¨‹
åŸºäº [å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­](.kiro/hooks/development-workflow-enhancement.kiro.hook)ï¼Œæ¯æ¬¡æ–‡ä»¶ç¼–è¾‘æ—¶è‡ªåŠ¨è§¦å‘å…¨é¢åˆ†æã€‚

```typescript
// è‡ªåŠ¨è§¦å‘æ–‡ä»¶æ¨¡å¼
const TRIGGER_PATTERNS = [
  "**/*.py", "**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx",
  "**/*.vue", "**/*.md", "requirements.txt", "package.json",
  "pyproject.toml", "Dockerfile", "docker-compose.yml",
  ".env*", "config/**/*", "docs/**/*", "tests/**/*"
];

interface WorkflowAnalysis {
  // é˜¶æ®µ1ï¼šå·¥ä½œå‰è´¨é‡ä¿è¯åˆ†æ
  mcpToolsAvailability: {
    serena: boolean;
    zen: boolean;
    memory: boolean;
    sequentialThinking: boolean;
    context7: boolean;
    time: boolean;
    git: boolean;
    fetch: boolean;
  };

  // å†å²ç»éªŒå¤ç”¨
  historicalLessons: {
    searchResults: any[];
    applicablePatterns: string[];
    riskPreventionMeasures: string[];
  };

  // å…¨å±€æ¶æ„ä¸€è‡´æ€§
  architectureConsistency: {
    analyzisResult: any;
    moduleBoundaryCheck: boolean;
    dependencyValidation: boolean;
    complianceScore: number;
  };

  // ä»£ç å†—ä½™æ£€æŸ¥
  redundancyValidation: {
    duplicateCodeCheck: any;
    similarModulesFound: string[];
    documentationConsistency: boolean;
  };
}
```

### å¼ºåˆ¶æ£€æŸ¥ç‚¹å®ç°
```typescript
// âœ… å·¥ä½œå‰å¼ºåˆ¶æ£€æŸ¥æµç¨‹
export class WorkflowEnhancementChecker {
  private mcpTools: MCPToolsManager;
  private memoryStore: MemoryStore;
  private codeAnalyzer: CodeAnalyzer;

  constructor() {
    this.mcpTools = new MCPToolsManager();
    this.memoryStore = new MemoryStore();
    this.codeAnalyzer = new CodeAnalyzer();
  }

  /**
   * æ‰§è¡Œå®Œæ•´çš„å·¥ä½œå‰åˆ†æ
   */
  async executePreWorkAnalysis(changedFiles: string[]): Promise<WorkflowAnalysis> {
    console.log("ğŸš€ å¼€å§‹æ‰§è¡Œå¼€å‘å·¥ä½œæµç¨‹å¢å¼ºåˆ†æ...");

    // é˜¶æ®µ1ï¼šMCPå·¥å…·å¯ç”¨æ€§æ£€æŸ¥
    const mcpAvailability = await this.checkMCPToolsAvailability();
    if (!this.validateMCPToolsReady(mcpAvailability)) {
      throw new Error("MCPå·¥å…·æœªå°±ç»ªï¼Œæ— æ³•ç»§ç»­å·¥ä½œ");
    }

    // é˜¶æ®µ2ï¼šå†å²ç»éªŒä¸é£é™©é¢„é˜²
    const historicalData = await this.analyzeHistoricalLessons(changedFiles);

    // é˜¶æ®µ3ï¼šæ¶æ„ä¸€è‡´æ€§æ£€æŸ¥
    const architectureCheck = await this.validateArchitectureConsistency(changedFiles);

    // é˜¶æ®µ4ï¼šå†—ä½™æ£€æŸ¥
    const redundancyCheck = await this.validateRedundancy(changedFiles);

    // é˜¶æ®µ5ï¼šå¼‚å¸¸çŠ¶æ€æ£€æŸ¥
    await this.checkSystemAnomalies();

    const analysis: WorkflowAnalysis = {
      mcpToolsAvailability: mcpAvailability,
      historicalLessons: historicalData,
      architectureConsistency: architectureCheck,
      redundancyValidation: redundancyCheck
    };

    // ç”Ÿæˆè¯¦ç»†è¯„ä¼°æŠ¥å‘Š
    await this.generateAssessmentReport(analysis);

    console.log("âœ… å·¥ä½œå‰åˆ†æå®Œæˆï¼Œå¯ä»¥å¼€å§‹å¼€å‘å·¥ä½œ");
    return analysis;
  }

  /**
   * æ£€æŸ¥MCPå·¥å…·å¯ç”¨æ€§
   */
  private async checkMCPToolsAvailability() {
    const tools = {
      serena: await this.mcpTools.isSerenaAvailable(),
      zen: await this.mcpTools.isZenAvailable(),
      memory: await this.mcpTools.isMemoryAvailable(),
      sequentialThinking: await this.mcpTools.isSequentialThinkingAvailable(),
      context7: await this.mcpTools.isContext7Available(),
      time: await this.mcpTools.isTimeAvailable(),
      git: await this.mcpTools.isGitAvailable(),
      fetch: await this.mcpTools.isFetchAvailable()
    };

    console.log("ğŸ” MCPå·¥å…·å¯ç”¨æ€§æ£€æŸ¥:", tools);
    return tools;
  }

  /**
   * éªŒè¯MCPå·¥å…·å°±ç»ªçŠ¶æ€
   */
  private validateMCPToolsReady(availability: any): boolean {
    const requiredTools = ['serena', 'memory', 'sequentialThinking'];
    const unavailableTools = requiredTools.filter(tool => !availability[tool]);

    if (unavailableTools.length > 0) {
      console.error(`âŒ å¿…éœ€çš„MCPå·¥å…·ä¸å¯ç”¨: ${unavailableTools.join(', ')}`);
      return false;
    }

    return true;
  }

  /**
   * åˆ†æå†å²ç»éªŒå’Œæ•™è®­
   */
  private async analyzeHistoricalLessons(files: string[]) {
    // ä½¿ç”¨memory.search_nodes()æŸ¥è¯¢ç›¸å…³å†å²ç»éªŒ
    const searchResults = await this.memoryStore.searchNodes({
      patterns: files.map(f => path.extname(f)),
      context: "development_experience",
      limit: 10
    });

    // åˆ†æå¯å¤ç”¨æ¨¡å¼
    const applicablePatterns = await this.memoryStore.findApplicablePatterns({
      currentFiles: files,
      searchResults: searchResults
    });

    // åˆ¶å®šé£é™©é¢„é˜²æªæ–½
    const riskMeasures = await this.memoryStore.getRiskPreventionMeasures({
      patterns: applicablePatterns,
      context: "file_modification"
    });

    return {
      searchResults,
      applicablePatterns,
      riskPreventionMeasures: riskMeasures
    };
  }

  /**
   * éªŒè¯æ¶æ„ä¸€è‡´æ€§
   */
  private async validateArchitectureConsistency(files: string[]) {
    // ä½¿ç”¨serena.architecture_analyze()åˆ†ææ¶æ„
    const analysisResult = await this.mcpTools.serena.architectureAnalyze(files);

    // æ£€æŸ¥æ¨¡å—è¾¹ç•Œ
    const moduleBoundaryCheck = await this.codeAnalyzer.validateModuleBoundaries(files);

    // éªŒè¯ä¾èµ–å…³ç³»
    const dependencyValidation = await this.codeAnalyzer.validateDependencies(files);

    // è®¡ç®—åˆè§„è¯„åˆ†
    const complianceScore = this.calculateComplianceScore({
      analysisResult,
      moduleBoundaryCheck,
      dependencyValidation
    });

    if (complianceScore < 90) {
      console.warn(`âš ï¸ æ¶æ„åˆè§„æ€§è¯„åˆ†è¾ƒä½: ${complianceScore}/100`);
    }

    return {
      analysisResult,
      moduleBoundaryCheck,
      dependencyValidation,
      complianceScore
    };
  }

  /**
   * éªŒè¯ä»£ç å’Œæ–‡æ¡£å†—ä½™
   */
  private async validateRedundancy(files: string[]) {
    // ä½¿ç”¨serena.duplicate_check()æ£€æµ‹é‡å¤ä»£ç 
    const duplicateCheck = await this.mcpTools.serena.duplicateCheck(files);

    // æœç´¢ç±»ä¼¼åŠŸèƒ½æ¨¡å—
    const similarModules = await this.codeAnalyzer.findSimilarModules(files);

    // éªŒè¯æ–‡æ¡£ä¸€è‡´æ€§
    const docConsistency = await this.codeAnalyzer.validateDocumentationConsistency();

    if (duplicateCheck.duplicates.length > 0) {
      console.warn(`âš ï¸ å‘ç°é‡å¤ä»£ç : ${duplicateCheck.duplicates.length}å¤„`);
    }

    return {
      duplicateCodeCheck: duplicateCheck,
      similarModulesFound: similarModules,
      documentationConsistency: docConsistency
    };
  }

  /**
   * æ£€æŸ¥ç³»ç»Ÿå¼‚å¸¸çŠ¶æ€
   */
  private async checkSystemAnomalies() {
    // æ£€æŸ¥ä¸Šæ¬¡å·¥ä½œé—ç•™é—®é¢˜
    const pendingIssues = await this.memoryStore.getPendingIssues();

    // éªŒè¯ç³»ç»Ÿè¿è¡ŒçŠ¶æ€
    const systemStatus = await this.checkSystemStatus();

    // ç¡®è®¤å¼€å‘ç¯å¢ƒé…ç½®
    const envValidation = await this.validateEnvironmentConfig();

    if (pendingIssues.length > 0) {
      console.warn(`âš ï¸ å‘ç°${pendingIssues.length}ä¸ªé—ç•™é—®é¢˜éœ€è¦å¤„ç†`);
    }

    if (!systemStatus.healthy) {
      throw new Error(`ç³»ç»ŸçŠ¶æ€å¼‚å¸¸: ${systemStatus.issues.join(', ')}`);
    }

    if (!envValidation.valid) {
      throw new Error(`ç¯å¢ƒé…ç½®å¼‚å¸¸: ${envValidation.errors.join(', ')}`);
    }
  }

  /**
   * ç”Ÿæˆè¯„ä¼°æŠ¥å‘Š
   */
  private async generateAssessmentReport(analysis: WorkflowAnalysis) {
    const report = {
      timestamp: new Date().toISOString(),
      mcpToolsStatus: analysis.mcpToolsAvailability,
      historicalInsights: analysis.historicalLessons.applicablePatterns,
      architectureScore: analysis.architectureConsistency.complianceScore,
      redundancyIssues: analysis.redundancyValidation.duplicateCodeCheck.duplicates.length,
      recommendations: this.generateRecommendations(analysis),
      readyToProceed: this.isReadyToProceed(analysis)
    };

    // å­˜å‚¨åˆ°memory
    await this.memoryStore.storeAssessmentReport(report);

    console.log("ğŸ“Š è¯„ä¼°æŠ¥å‘Šå·²ç”Ÿæˆå¹¶å­˜å‚¨");
    return report;
  }

  /**
   * ç”Ÿæˆæ”¹è¿›å»ºè®®
   */
  private generateRecommendations(analysis: WorkflowAnalysis): string[] {
    const recommendations: string[] = [];

    if (analysis.architectureConsistency.complianceScore < 90) {
      recommendations.push("å»ºè®®ä¼˜åŒ–æ¶æ„è®¾è®¡ï¼Œæé«˜åˆè§„æ€§è¯„åˆ†");
    }

    if (analysis.redundancyValidation.duplicateCodeCheck.duplicates.length > 0) {
      recommendations.push("å»ºè®®é‡æ„é‡å¤ä»£ç ï¼Œæé«˜ä»£ç å¤ç”¨æ€§");
    }

    if (analysis.redundancyValidation.similarModulesFound.length > 0) {
      recommendations.push("å‘ç°ç›¸ä¼¼æ¨¡å—ï¼Œå»ºè®®åˆå¹¶æˆ–æŠ½è±¡å…¬å…±åŠŸèƒ½");
    }

    return recommendations;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦å‡†å¤‡å¥½ç»§ç»­å·¥ä½œ
   */
  private isReadyToProceed(analysis: WorkflowAnalysis): boolean {
    // æ£€æŸ¥é˜»å¡æ¡ä»¶
    const blockingIssues = [
      analysis.architectureConsistency.complianceScore < 80,
      !analysis.architectureConsistency.moduleBoundaryCheck,
      !analysis.redundancyValidation.documentationConsistency
    ];

    return !blockingIssues.some(issue => issue);
  }
}
```

## ğŸ“‹ é¡¹ç›®æ ‡å‡†åˆè§„æ£€æŸ¥é’©å­

### æäº¤å‰å¼ºåˆ¶æ£€æŸ¥
åŸºäº [é¡¹ç›®æ ‡å‡†åˆè§„é’©å­](.kiro/hooks/project-standards-compliance.kiro.hook)ï¼Œåœ¨æ¯æ¬¡æäº¤å‰è‡ªåŠ¨æ‰§è¡Œå…¨é¢çš„åˆè§„æ£€æŸ¥ã€‚

```typescript
// è‡ªåŠ¨è§¦å‘ï¼šbeforeCommitäº‹ä»¶ï¼ŒåŒ¹é…æ‰€æœ‰æ–‡ä»¶
export class ProjectStandardsComplianceChecker {
  private serena: SerenaTools;
  private qualityGates: QualityGates;

  /**
   * æ‰§è¡Œå®Œæ•´çš„é¡¹ç›®è§„èŒƒéµå¾ªæ£€æŸ¥
   */
  async executeComplianceCheck(files: string[]): Promise<ComplianceResult> {
    console.log("ğŸ“‹ å¼€å§‹æ‰§è¡Œé¡¹ç›®è§„èŒƒéµå¾ªæ£€æŸ¥...");

    const results = {
      pythonCompliance: await this.checkPythonCompliance(files),
      typescriptCompliance: await this.checkTypescriptCompliance(files),
      documentationCompliance: await this.checkDocumentationCompliance(files),
      testingCompliance: await this.checkTestingCompliance(files),
      securityCompliance: await this.checkSecurityCompliance(files),
      performanceCompliance: await this.checkPerformanceCompliance(files),
      structureCompliance: await this.checkStructureCompliance(files),
      versionControlCompliance: await this.checkVersionControlCompliance(files),
      windowsCompliance: await this.checkWindowsCompliance(files)
    };

    // éªŒè¯æ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡
    const overallResult = this.validateOverallCompliance(results);

    if (!overallResult.passed) {
      throw new Error(`åˆè§„æ£€æŸ¥å¤±è´¥: ${overallResult.failures.join(', ')}`);
    }

    console.log("âœ… æ‰€æœ‰é¡¹ç›®è§„èŒƒéµå¾ªæ£€æŸ¥é€šè¿‡");
    return overallResult;
  }

  /**
   * Pythonå¼€å‘è§„èŒƒæ£€æŸ¥
   */
  private async checkPythonCompliance(files: string[]) {
    const pythonFiles = files.filter(f => f.endsWith('.py'));
    if (pythonFiles.length === 0) return { passed: true, issues: [] };

    const checks = [
      await this.serena.styleCheck(pythonFiles), // PEP 8æ£€æŸ¥
      await this.serena.complexityCheck(pythonFiles), // å¤æ‚åº¦æ£€æŸ¥
      await this.checkTypeAnnotations(pythonFiles), // ç±»å‹æ³¨è§£æ£€æŸ¥
      await this.checkAsyncUsage(pythonFiles), // å¼‚æ­¥ç¼–ç¨‹æ£€æŸ¥
      await this.checkExceptionHandling(pythonFiles), // å¼‚å¸¸å¤„ç†æ£€æŸ¥
      await this.checkLoggingUsage(pythonFiles) // æ—¥å¿—ä½¿ç”¨æ£€æŸ¥
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * TypeScriptå¼€å‘è§„èŒƒæ£€æŸ¥
   */
  private async checkTypescriptCompliance(files: string[]) {
    const tsFiles = files.filter(f => f.match(/\.(ts|tsx)$/));
    if (tsFiles.length === 0) return { passed: true, issues: [] };

    const checks = [
      await this.serena.styleCheck(tsFiles), // ESLintæ£€æŸ¥
      await this.checkStrictMode(tsFiles), // ä¸¥æ ¼æ¨¡å¼æ£€æŸ¥
      await this.checkTypeDefinitions(tsFiles), // ç±»å‹å®šä¹‰æ£€æŸ¥
      await this.checkComponentStructure(tsFiles), // ç»„ä»¶ç»“æ„æ£€æŸ¥
      await this.checkImportOrganization(tsFiles) // å¯¼å…¥ç»„ç»‡æ£€æŸ¥
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * æµ‹è¯•è§„èŒƒåˆè§„æ£€æŸ¥
   */
  private async checkTestingCompliance(files: string[]) {
    const coverage = await this.serena.testCoverage(files);
    const testFiles = files.filter(f => f.match(/\.(test|spec)\.(ts|tsx|py)$/));

    const checks = [
      {
        name: "æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥",
        passed: coverage.percentage >= 85,
        message: `æµ‹è¯•è¦†ç›–ç‡: ${coverage.percentage}% (è¦æ±‚â‰¥85%)`
      },
      {
        name: "æµ‹è¯•æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥",
        passed: testFiles.length > 0 || files.length === 0,
        message: testFiles.length === 0 ? "æ²¡æœ‰æ‰¾åˆ°æµ‹è¯•æ–‡ä»¶" : "æ‰¾åˆ°æµ‹è¯•æ–‡ä»¶"
      }
    ];

    // è¿è¡Œæµ‹è¯•
    if (testFiles.length > 0) {
      const testResult = await this.serena.testRun(testFiles);
      checks.push({
        name: "æµ‹è¯•æ‰§è¡Œæ£€æŸ¥",
        passed: testResult.success,
        message: testResult.success ? "æ‰€æœ‰æµ‹è¯•é€šè¿‡" : `${testResult.failedCount}ä¸ªæµ‹è¯•å¤±è´¥`
      });
    }

    return this.aggregateCheckResults(checks);
  }

  /**
   * å®‰å…¨è§„èŒƒåˆè§„æ£€æŸ¥
   */
  private async checkSecurityCompliance(files: string[]) {
    const checks = [
      await this.serena.securityScan(files), // å®‰å…¨æ¼æ´æ‰«æ
      await this.serena.secretScan(files), // æ•æ„Ÿä¿¡æ¯æ‰«æ
      await this.serena.dependencyCheck(files), // ä¾èµ–å®‰å…¨æ£€æŸ¥
      await this.serena.permissionCheck(files) // æƒé™æ£€æŸ¥
    ];

    // éªŒè¯æ— é«˜å±æ¼æ´
    const securityScan = checks[0];
    const highRiskVulns = securityScan.vulnerabilities?.filter(v => v.severity === 'high') || [];

    if (highRiskVulns.length > 0) {
      checks.push({
        name: "é«˜å±æ¼æ´æ£€æŸ¥",
        passed: false,
        message: `å‘ç°${highRiskVulns.length}ä¸ªé«˜å±å®‰å…¨æ¼æ´`
      });
    }

    return this.aggregateCheckResults(checks);
  }

  /**
   * Windowsç¯å¢ƒç‰¹æ®Šåˆè§„æ£€æŸ¥
   */
  private async checkWindowsCompliance(files: string[]) {
    const checks = [
      await this.checkPathHandling(files), // è·¯å¾„å¤„ç†æ£€æŸ¥
      await this.checkPowerShellCompatibility(files), // PowerShellå…¼å®¹æ€§
      await this.checkFileEncoding(files), // æ–‡ä»¶ç¼–ç æ£€æŸ¥
      await this.checkLineEndings(files) // æ¢è¡Œç¬¦æ£€æŸ¥
    ];

    return this.aggregateCheckResults(checks);
  }

  /**
   * è´¨é‡é—¨ç¦éªŒè¯
   */
  private validateOverallCompliance(results: any): ComplianceResult {
    const allChecks = Object.values(results).flat();
    const failures = allChecks.filter((check: any) => !check.passed);

    return {
      passed: failures.length === 0,
      totalChecks: allChecks.length,
      passedChecks: allChecks.length - failures.length,
      failures: failures.map((f: any) => f.message || f.name),
      timestamp: new Date().toISOString()
    };
  }
}
```

## âš ï¸ Windowsç¯å¢ƒçº¦æŸ

### ç¦æ­¢äº‹é¡¹
- âŒ ä½¿ç”¨Linuxä¸“ç”¨å‘½ä»¤å’Œè¯­æ³•
- âŒ ç¡¬ç¼–ç Unixè·¯å¾„åˆ†éš”ç¬¦
- âŒ å¿½ç•¥Windowsæ–‡ä»¶è·¯å¾„é•¿åº¦é™åˆ¶
- âŒ ä¸å¤„ç†Windowsæƒé™ç‰¹æ®Šæ€§
- âŒ ä½¿ç”¨ä¸å…¼å®¹PowerShellçš„è„šæœ¬è¯­æ³•

### æœ€ä½³å®è·µ
- âœ… ä½¿ç”¨PowerShellä½œä¸ºé»˜è®¤Shell
- âœ… ä½¿ç”¨è·¨å¹³å°çš„è·¯å¾„å¤„ç†å‡½æ•°
- âœ… æ­£ç¡®å¤„ç†Windowsé•¿è·¯å¾„é—®é¢˜
- âœ… è€ƒè™‘Windowsé˜²ç«å¢™å’Œæƒé™è®¾ç½®
- âœ… ä½¿ç”¨Windowså…¼å®¹çš„æ–‡ä»¶ç¼–ç 

---

**å‚è€ƒæ–‡æ¡£**:
- [å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­](.kiro/hooks/development-workflow-enhancement.kiro.hook)
- [é¡¹ç›®æ ‡å‡†åˆè§„é’©å­](.kiro/hooks/project-standards-compliance.kiro.hook)
- [å·¥ä½œè´¨é‡ä¿è¯é’©å­](.kiro/hooks/work-quality-assurance.kiro.hook)
