---
alwaysApply: true
---
# ZK-Agent MCPå·¥å…·å¼ºåˆ¶ä½¿ç”¨è§„èŒƒ

## ğŸ“‹ æ ¸å¿ƒåŸåˆ™

åŸºäº [MCPå·¥å…·æŒ‡å¯¼é’©å­](.kiro/hooks/mcp-tools-guidance.kiro.hook)ï¼Œ**æ¯ä¸ªå¼€å‘å·¥ä½œå¿…é¡»å……åˆ†ä½¿ç”¨MCPå·¥å…·**ã€‚è¿åæ­¤è§„åˆ™å°†å¯¼è‡´å·¥ä½œæµç¨‹å¼ºåˆ¶ç»ˆæ­¢ã€‚

### å¼ºåˆ¶ä½¿ç”¨è¦æ±‚
- ğŸš¨ **TaskManager ä¸ Mentor å¼ºåˆ¶åä½œ**: æ‰€æœ‰é‡è¦å†³ç­–å¿…é¡»ç»è¿‡åŒé‡éªŒè¯
- ğŸš¨ **ä»£ç å®¡æŸ¥å¿…é¡»ä½¿ç”¨ Mentor**: ä¸å¾—ç»•è¿‡ Mentor ä»£ç å®¡æŸ¥æœºåˆ¶
- ğŸš¨ **è´¨é‡æ§åˆ¶å¼ºåˆ¶ Serena**: ä»£ç è´¨é‡æ£€æŸ¥å¿…é¡»é€šè¿‡ Serena éªŒè¯
- ğŸš¨ **è®°å¿†ç®¡ç†å¼ºåˆ¶ Memory**: å…³é”®å†³ç­–å’Œç»éªŒå¿…é¡»å­˜å‚¨åˆ° Memory

## ğŸ› ï¸ TaskManager æ ¸å¿ƒåŠŸèƒ½å¼ºåˆ¶ä½¿ç”¨

### å¿…é¡»ä½¿ç”¨çš„åŠŸèƒ½
```typescript
interface TaskManagerRequiredUsage {
  // ä»»åŠ¡è°ƒåº¦ä¸ç®¡ç†
  taskScheduling: {
    "TaskManager.schedule_task()": "ä»»åŠ¡åˆ›å»ºå’Œè°ƒåº¦";
    "TaskManager.monitor_progress()": "è¿›åº¦å®æ—¶ç›‘æ§";
    "TaskManager.handle_dependencies()": "ä¾èµ–å…³ç³»ç®¡ç†";
    "TaskManager.resource_allocation()": "èµ„æºåˆ†é…ä¼˜åŒ–";
  };

  // çŠ¶æ€ç›‘æ§ä¸è¿½è¸ª
  statusMonitoring: {
    "TaskManager.track_status()": "çŠ¶æ€å˜æ›´è¿½è¸ª";
    "TaskManager.performance_metrics()": "æ€§èƒ½æŒ‡æ ‡ç›‘æ§";
    "TaskManager.bottleneck_detection()": "ç“¶é¢ˆæ£€æµ‹";
    "TaskManager.health_check()": "ç³»ç»Ÿå¥åº·æ£€æŸ¥";
  };

  // é”™è¯¯å¤„ç†ä¸æ¢å¤
  errorHandling: {
    "TaskManager.error_recovery()": "è‡ªåŠ¨é”™è¯¯æ¢å¤";
    "TaskManager.rollback_strategy()": "å›æ»šç­–ç•¥æ‰§è¡Œ";
    "TaskManager.incident_management()": "äº‹æ•…ç®¡ç†";
    "TaskManager.failure_analysis()": "å¤±è´¥åŸå› åˆ†æ";
  };

  // é…ç½®ç®¡ç†ä¸åŠ è½½
  configManagement: {
    "TaskManager.load_config()": "é…ç½®æ–‡ä»¶åŠ è½½";
    "TaskManager.validate_config()": "é…ç½®éªŒè¯";
    "TaskManager.hot_reload()": "çƒ­é‡è½½é…ç½®";
    "TaskManager.environment_sync()": "ç¯å¢ƒåŒæ­¥";
  };
}
```

### ä½¿ç”¨ç¤ºä¾‹
```typescript
// âœ… æ­£ç¡®çš„TaskManagerä½¿ç”¨
async function developNewFeature(featureSpec: FeatureSpec) {
  // 1. åˆ›å»ºä»»åŠ¡å¹¶è°ƒåº¦
  const task = await TaskManager.schedule_task({
    name: "develop-new-feature",
    spec: featureSpec,
    priority: "high",
    estimatedTime: "2h"
  });

  // 2. ç›‘æ§ä»»åŠ¡è¿›åº¦
  TaskManager.monitor_progress(task.id, (progress) => {
    console.log(`å¼€å‘è¿›åº¦: ${progress.percentage}%`);
  });

  // 3. å¤„ç†ä¾èµ–å…³ç³»
  await TaskManager.handle_dependencies(task.id, [
    "database-migration",
    "api-endpoint-setup"
  ]);

  // 4. åˆ†é…èµ„æº
  const resources = await TaskManager.resource_allocation({
    taskId: task.id,
    requiredResources: ["cpu", "memory", "database"]
  });

  return task;
}
```

## ğŸ§  Mentor æŒ‡å¯¼è¿‡ç¨‹å¼ºåˆ¶è¦æ±‚

### ä»£ç å®¡æŸ¥å¼ºåˆ¶æµç¨‹
```typescript
interface MentorRequiredUsage {
  // ä»£ç å®¡æŸ¥åŠŸèƒ½ï¼ˆå¼ºåˆ¶ï¼‰
  codeReview: {
    "Mentor.review_code()": "ä»£ç è´¨é‡å®¡æŸ¥";
    "Mentor.style_check()": "ä»£ç é£æ ¼æ£€æŸ¥";
    "Mentor.security_audit()": "å®‰å…¨æ¼æ´å®¡è®¡";
    "Mentor.performance_analysis()": "æ€§èƒ½ç“¶é¢ˆåˆ†æ";
  };

  // æ¶æ„è®¾è®¡åŠŸèƒ½ï¼ˆå¼ºåˆ¶ï¼‰
  architectureReview: {
    "Mentor.validate_architecture()": "æ¶æ„è®¾è®¡éªŒè¯";
    "Mentor.design_pattern_check()": "è®¾è®¡æ¨¡å¼æ£€æŸ¥";
    "Mentor.dependency_analysis()": "ä¾èµ–å…³ç³»åˆ†æ";
    "Mentor.scalability_assessment()": "å¯æ‰©å±•æ€§è¯„ä¼°";
  };

  // è´¨é‡æŠŠæ§åŠŸèƒ½ï¼ˆå¼ºåˆ¶ï¼‰
  qualityControl: {
    "Mentor.quality_metrics()": "è´¨é‡åº¦é‡åˆ†æ";
    "Mentor.test_coverage_check()": "æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥";
    "Mentor.maintainability_score()": "å¯ç»´æŠ¤æ€§è¯„åˆ†";
    "Mentor.technical_debt_analysis()": "æŠ€æœ¯å€ºåŠ¡åˆ†æ";
  };
}
```

### å¼ºåˆ¶å®¡æŸ¥æ£€æŸ¥ç‚¹
```typescript
// âœ… æ¯æ¬¡ä»£ç å˜æ›´å¿…é¡»æ‰§è¡Œ
async function codeChangeWorkflow(changes: CodeChange[]) {
  // 1. å¼ºåˆ¶ä»£ç å®¡æŸ¥
  const reviewResult = await Mentor.review_code(changes);
  if (!reviewResult.approved) {
    throw new Error(`ä»£ç å®¡æŸ¥æœªé€šè¿‡: ${reviewResult.issues.join(', ')}`);
  }

  // 2. å¼ºåˆ¶æ¶æ„éªŒè¯
  const archValidation = await Mentor.validate_architecture(changes);
  if (!archValidation.compliant) {
    throw new Error(`æ¶æ„éªŒè¯å¤±è´¥: ${archValidation.violations.join(', ')}`);
  }

  // 3. å¼ºåˆ¶å®‰å…¨æ£€æŸ¥
  const securityCheck = await Mentor.security_audit(changes);
  if (securityCheck.vulnerabilities.length > 0) {
    throw new Error(`å‘ç°å®‰å…¨æ¼æ´: ${securityCheck.vulnerabilities.length}ä¸ª`);
  }

  // 4. å¼ºåˆ¶è´¨é‡æ£€æŸ¥
  const qualityCheck = await Mentor.quality_metrics(changes);
  if (qualityCheck.score < 90) {
    throw new Error(`ä»£ç è´¨é‡è¯„åˆ†è¿‡ä½: ${qualityCheck.score}/100`);
  }

  return { approved: true, metrics: qualityCheck };
}
```

## ğŸ”§ Serena ä»£ç è´¨é‡ç®¡ç†å¼ºåˆ¶ä½¿ç”¨

### å¿…é¡»ä½¿ç”¨çš„SerenaåŠŸèƒ½
```typescript
interface SerenaRequiredUsage {
  // ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆå¼ºåˆ¶ï¼‰
  qualityChecks: {
    "serena.code_review()": "å…¨é¢ä»£ç å®¡æŸ¥";
    "serena.style_check()": "ä»£ç é£æ ¼æ£€æŸ¥";
    "serena.complexity_check()": "å¤æ‚åº¦åˆ†æ";
    "serena.duplicate_check()": "é‡å¤ä»£ç æ£€æµ‹";
    "serena.naming_check()": "å‘½åè§„èŒƒæ£€æŸ¥";
  };

  // æµ‹è¯•ç®¡ç†ï¼ˆå¼ºåˆ¶ï¼‰
  testManagement: {
    "serena.test_coverage()": "æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥";
    "serena.test_generate()": "è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹";
    "serena.test_run()": "æ‰§è¡Œæµ‹è¯•å¥—ä»¶";
    "serena.benchmark_test()": "æ€§èƒ½åŸºå‡†æµ‹è¯•";
  };

  // å®‰å…¨æ£€æŸ¥ï¼ˆå¼ºåˆ¶ï¼‰
  securityChecks: {
    "serena.security_scan()": "å®‰å…¨æ¼æ´æ‰«æ";
    "serena.dependency_check()": "ä¾èµ–åŒ…å®‰å…¨æ£€æŸ¥";
    "serena.secret_scan()": "æ•æ„Ÿä¿¡æ¯æ‰«æ";
    "serena.permission_check()": "æƒé™æ£€æŸ¥";
  };

  // æ€§èƒ½åˆ†æï¼ˆå¼ºåˆ¶ï¼‰
  performanceAnalysis: {
    "serena.performance_analyze()": "æ€§èƒ½åˆ†æ";
    "serena.memory_profile()": "å†…å­˜åˆ†æ";
    "serena.bottleneck_detect()": "æ€§èƒ½ç“¶é¢ˆæ£€æµ‹";
    "serena.optimization_suggest()": "ä¼˜åŒ–å»ºè®®";
  };
}
```

### è´¨é‡é—¨ç¦å¼ºåˆ¶æ£€æŸ¥
```typescript
// âœ… æäº¤å‰å¼ºåˆ¶è´¨é‡æ£€æŸ¥
async function preCommitQualityGate(files: string[]) {
  console.log("ğŸ” æ‰§è¡Œå¼ºåˆ¶è´¨é‡æ£€æŸ¥...");

  // 1. ä»£ç é£æ ¼æ£€æŸ¥ï¼ˆå¼ºåˆ¶é€šè¿‡ï¼‰
  const styleResult = await serena.style_check(files);
  if (!styleResult.passed) {
    throw new Error(`ä»£ç é£æ ¼æ£€æŸ¥å¤±è´¥: ${styleResult.errors.length}ä¸ªé”™è¯¯`);
  }

  // 2. å¤æ‚åº¦æ£€æŸ¥ï¼ˆå¼ºåˆ¶é€šè¿‡ï¼‰
  const complexityResult = await serena.complexity_check(files);
  if (complexityResult.averageComplexity > 10) {
    throw new Error(`ä»£ç å¤æ‚åº¦è¿‡é«˜: ${complexityResult.averageComplexity}`);
  }

  // 3. å®‰å…¨æ‰«æï¼ˆå¼ºåˆ¶é€šè¿‡ï¼‰
  const securityResult = await serena.security_scan(files);
  if (securityResult.vulnerabilities.length > 0) {
    throw new Error(`å‘ç°å®‰å…¨æ¼æ´: ${securityResult.vulnerabilities.length}ä¸ª`);
  }

  // 4. æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥ï¼ˆå¼ºåˆ¶â‰¥85%ï¼‰
  const coverageResult = await serena.test_coverage(files);
  if (coverageResult.percentage < 85) {
    throw new Error(`æµ‹è¯•è¦†ç›–ç‡ä¸è¶³: ${coverageResult.percentage}% < 85%`);
  }

  console.log("âœ… æ‰€æœ‰è´¨é‡æ£€æŸ¥é€šè¿‡");
  return true;
}
```

## ğŸ§  Memory çŸ¥è¯†ç®¡ç†å¼ºåˆ¶ä½¿ç”¨

### å¼ºåˆ¶è®°å½•çš„ä¿¡æ¯ç±»å‹
```typescript
interface MemoryRequiredUsage {
  // è®¾è®¡å†³ç­–è®°å½•ï¼ˆå¼ºåˆ¶ï¼‰
  designDecisions: {
    "memory.store_decision()": "é‡è¦è®¾è®¡å†³ç­–å­˜å‚¨";
    "memory.retrieve_patterns()": "å†å²æ¨¡å¼æ£€ç´¢";
    "memory.analyze_trends()": "è¶‹åŠ¿åˆ†æ";
  };

  // é”™è¯¯ç»éªŒè®°å½•ï¼ˆå¼ºåˆ¶ï¼‰
  errorExperience: {
    "memory.record_failure()": "å¤±è´¥ç»éªŒè®°å½•";
    "memory.solution_mapping()": "è§£å†³æ–¹æ¡ˆæ˜ å°„";
    "memory.prevention_strategy()": "é¢„é˜²ç­–ç•¥å­˜å‚¨";
  };

  // æœ€ä½³å®è·µè®°å½•ï¼ˆå¼ºåˆ¶ï¼‰
  bestPractices: {
    "memory.store_practice()": "æœ€ä½³å®è·µå­˜å‚¨";
    "memory.context_mapping()": "ä¸Šä¸‹æ–‡æ˜ å°„";
    "memory.reuse_analysis()": "å¤ç”¨æ€§åˆ†æ";
  };
}
```

### å¼ºåˆ¶è®°å½•å·¥ä½œæµ
```typescript
// âœ… æ¯æ¬¡é‡è¦å·¥ä½œç»“æŸåå¼ºåˆ¶è®°å½•
async function recordWorkExperience(work: WorkSession) {
  // 1. è®°å½•è®¾è®¡å†³ç­–
  await memory.store_decision({
    type: "architecture_choice",
    decision: work.decisions,
    context: work.context,
    reasoning: work.reasoning,
    outcomes: work.outcomes
  });

  // 2. è®°å½•é‡åˆ°çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
  for (const issue of work.issues) {
    await memory.record_failure({
      problem: issue.description,
      solution: issue.solution,
      prevention: issue.preventionStrategy,
      tags: issue.tags
    });
  }

  // 3. è®°å½•å¯å¤ç”¨çš„æœ€ä½³å®è·µ
  await memory.store_practice({
    pattern: work.successfulPatterns,
    context: work.applicableContexts,
    benefits: work.benefits,
    limitations: work.limitations
  });
}
```

## ğŸ”„ Sequential Thinking ä¸ Context7 ååŒä½¿ç”¨

### é—®é¢˜åˆ†æå¼ºåˆ¶æµç¨‹
```typescript
// âœ… å¤æ‚é—®é¢˜å¿…é¡»ä½¿ç”¨Sequential Thinkingåˆ†è§£
async function solveComplexProblem(problem: ComplexProblem) {
  // 1. ä½¿ç”¨Sequential Thinkingåˆ†è§£é—®é¢˜
  const decomposition = await sequentialThinking.decompose({
    problem: problem.description,
    constraints: problem.constraints,
    goals: problem.goals
  });

  // 2. ä½¿ç”¨Context7è·å–ç›¸å…³æŠ€æœ¯æ–‡æ¡£
  const relevantDocs = await context7.search({
    query: problem.keywords,
    type: "technical_documentation",
    limit: 10
  });

  // 3. ç»“åˆå†å²ç»éªŒ
  const historicalSolutions = await memory.search({
    pattern: problem.pattern,
    context: problem.context
  });

  // 4. åˆ¶å®šåˆ†æ­¥è§£å†³æ–¹æ¡ˆ
  const solution = await sequentialThinking.synthesize({
    subProblems: decomposition.subProblems,
    resources: relevantDocs,
    experience: historicalSolutions
  });

  return solution;
}
```

## âš ï¸ è¿è§„å¤„ç†æœºåˆ¶

### å¼ºåˆ¶ä¸­æ–­æ¡ä»¶
1. **ç»•è¿‡Mentorä»£ç å®¡æŸ¥**: ç«‹å³ä¸­æ–­å·¥ä½œæµç¨‹
2. **è·³è¿‡Serenaè´¨é‡æ£€æŸ¥**: æ‹’ç»ä»£ç æäº¤
3. **æœªä½¿ç”¨TaskManagerè°ƒåº¦**: å·¥ä½œæ— æ•ˆåŒ–
4. **æœªè®°å½•åˆ°Memory**: ç»éªŒæ— æ³•ç§¯ç´¯ï¼Œå½±å“è¯„ä¼°

### åˆè§„æ€§æ£€æŸ¥
```typescript
// âœ… å·¥ä½œå¼€å§‹å‰çš„åˆè§„æ€§æ£€æŸ¥
async function complianceCheck(workPlan: WorkPlan) {
  const checks = [
    TaskManager.isAvailable(),
    Mentor.isConfigured(),
    serena.isActive(),
    memory.isAccessible(),
    sequentialThinking.isReady(),
    context7.isConnected()
  ];

  const results = await Promise.all(checks);
  const failedTools = results
    .map((result, index) => ({ result, tool: TOOL_NAMES[index] }))
    .filter(({ result }) => !result)
    .map(({ tool }) => tool);

  if (failedTools.length > 0) {
    throw new Error(`MCPå·¥å…·æœªå°±ç»ª: ${failedTools.join(', ')}`);
  }

  console.log("âœ… æ‰€æœ‰MCPå·¥å…·å°±ç»ªï¼Œå¯ä»¥å¼€å§‹å·¥ä½œ");
  return true;
}
```

---

**å‚è€ƒæ–‡æ¡£**:
- [MCPå·¥å…·æŒ‡å¯¼é’©å­](.kiro/hooks/mcp-tools-guidance.kiro.hook)
- [å·¥ä½œè´¨é‡ä¿è¯é’©å­](.kiro/hooks/work-quality-assurance.kiro.hook)
- [å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­](.kiro/hooks/development-workflow-enhancement.kiro.hook)
# ZK-Agent MCPå·¥å…·å¼ºåˆ¶ä½¿ç”¨è§„èŒƒ

## ğŸ“‹ æ ¸å¿ƒåŸåˆ™

åŸºäº [MCPå·¥å…·æŒ‡å¯¼é’©å­](.kiro/hooks/mcp-tools-guidance.kiro.hook)ï¼Œ**æ¯ä¸ªå¼€å‘å·¥ä½œå¿…é¡»å……åˆ†ä½¿ç”¨MCPå·¥å…·**ã€‚è¿åæ­¤è§„åˆ™å°†å¯¼è‡´å·¥ä½œæµç¨‹å¼ºåˆ¶ç»ˆæ­¢ã€‚

### å¼ºåˆ¶ä½¿ç”¨è¦æ±‚
- ğŸš¨ **TaskManager ä¸ Mentor å¼ºåˆ¶åä½œ**: æ‰€æœ‰é‡è¦å†³ç­–å¿…é¡»ç»è¿‡åŒé‡éªŒè¯
- ğŸš¨ **ä»£ç å®¡æŸ¥å¿…é¡»ä½¿ç”¨ Mentor**: ä¸å¾—ç»•è¿‡ Mentor ä»£ç å®¡æŸ¥æœºåˆ¶
- ğŸš¨ **è´¨é‡æ§åˆ¶å¼ºåˆ¶ Serena**: ä»£ç è´¨é‡æ£€æŸ¥å¿…é¡»é€šè¿‡ Serena éªŒè¯
- ğŸš¨ **è®°å¿†ç®¡ç†å¼ºåˆ¶ Memory**: å…³é”®å†³ç­–å’Œç»éªŒå¿…é¡»å­˜å‚¨åˆ° Memory

## ğŸ› ï¸ TaskManager æ ¸å¿ƒåŠŸèƒ½å¼ºåˆ¶ä½¿ç”¨

### å¿…é¡»ä½¿ç”¨çš„åŠŸèƒ½
```typescript
interface TaskManagerRequiredUsage {
  // ä»»åŠ¡è°ƒåº¦ä¸ç®¡ç†
  taskScheduling: {
    "TaskManager.schedule_task()": "ä»»åŠ¡åˆ›å»ºå’Œè°ƒåº¦";
    "TaskManager.monitor_progress()": "è¿›åº¦å®æ—¶ç›‘æ§";
    "TaskManager.handle_dependencies()": "ä¾èµ–å…³ç³»ç®¡ç†";
    "TaskManager.resource_allocation()": "èµ„æºåˆ†é…ä¼˜åŒ–";
  };

  // çŠ¶æ€ç›‘æ§ä¸è¿½è¸ª
  statusMonitoring: {
    "TaskManager.track_status()": "çŠ¶æ€å˜æ›´è¿½è¸ª";
    "TaskManager.performance_metrics()": "æ€§èƒ½æŒ‡æ ‡ç›‘æ§";
    "TaskManager.bottleneck_detection()": "ç“¶é¢ˆæ£€æµ‹";
    "TaskManager.health_check()": "ç³»ç»Ÿå¥åº·æ£€æŸ¥";
  };

  // é”™è¯¯å¤„ç†ä¸æ¢å¤
  errorHandling: {
    "TaskManager.error_recovery()": "è‡ªåŠ¨é”™è¯¯æ¢å¤";
    "TaskManager.rollback_strategy()": "å›æ»šç­–ç•¥æ‰§è¡Œ";
    "TaskManager.incident_management()": "äº‹æ•…ç®¡ç†";
    "TaskManager.failure_analysis()": "å¤±è´¥åŸå› åˆ†æ";
  };

  // é…ç½®ç®¡ç†ä¸åŠ è½½
  configManagement: {
    "TaskManager.load_config()": "é…ç½®æ–‡ä»¶åŠ è½½";
    "TaskManager.validate_config()": "é…ç½®éªŒè¯";
    "TaskManager.hot_reload()": "çƒ­é‡è½½é…ç½®";
    "TaskManager.environment_sync()": "ç¯å¢ƒåŒæ­¥";
  };
}
```

### ä½¿ç”¨ç¤ºä¾‹
```typescript
// âœ… æ­£ç¡®çš„TaskManagerä½¿ç”¨
async function developNewFeature(featureSpec: FeatureSpec) {
  // 1. åˆ›å»ºä»»åŠ¡å¹¶è°ƒåº¦
  const task = await TaskManager.schedule_task({
    name: "develop-new-feature",
    spec: featureSpec,
    priority: "high",
    estimatedTime: "2h"
  });

  // 2. ç›‘æ§ä»»åŠ¡è¿›åº¦
  TaskManager.monitor_progress(task.id, (progress) => {
    console.log(`å¼€å‘è¿›åº¦: ${progress.percentage}%`);
  });

  // 3. å¤„ç†ä¾èµ–å…³ç³»
  await TaskManager.handle_dependencies(task.id, [
    "database-migration",
    "api-endpoint-setup"
  ]);

  // 4. åˆ†é…èµ„æº
  const resources = await TaskManager.resource_allocation({
    taskId: task.id,
    requiredResources: ["cpu", "memory", "database"]
  });

  return task;
}
```

## ğŸ§  Mentor æŒ‡å¯¼è¿‡ç¨‹å¼ºåˆ¶è¦æ±‚

### ä»£ç å®¡æŸ¥å¼ºåˆ¶æµç¨‹
```typescript
interface MentorRequiredUsage {
  // ä»£ç å®¡æŸ¥åŠŸèƒ½ï¼ˆå¼ºåˆ¶ï¼‰
  codeReview: {
    "Mentor.review_code()": "ä»£ç è´¨é‡å®¡æŸ¥";
    "Mentor.style_check()": "ä»£ç é£æ ¼æ£€æŸ¥";
    "Mentor.security_audit()": "å®‰å…¨æ¼æ´å®¡è®¡";
    "Mentor.performance_analysis()": "æ€§èƒ½ç“¶é¢ˆåˆ†æ";
  };

  // æ¶æ„è®¾è®¡åŠŸèƒ½ï¼ˆå¼ºåˆ¶ï¼‰
  architectureReview: {
    "Mentor.validate_architecture()": "æ¶æ„è®¾è®¡éªŒè¯";
    "Mentor.design_pattern_check()": "è®¾è®¡æ¨¡å¼æ£€æŸ¥";
    "Mentor.dependency_analysis()": "ä¾èµ–å…³ç³»åˆ†æ";
    "Mentor.scalability_assessment()": "å¯æ‰©å±•æ€§è¯„ä¼°";
  };

  // è´¨é‡æŠŠæ§åŠŸèƒ½ï¼ˆå¼ºåˆ¶ï¼‰
  qualityControl: {
    "Mentor.quality_metrics()": "è´¨é‡åº¦é‡åˆ†æ";
    "Mentor.test_coverage_check()": "æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥";
    "Mentor.maintainability_score()": "å¯ç»´æŠ¤æ€§è¯„åˆ†";
    "Mentor.technical_debt_analysis()": "æŠ€æœ¯å€ºåŠ¡åˆ†æ";
  };
}
```

### å¼ºåˆ¶å®¡æŸ¥æ£€æŸ¥ç‚¹
```typescript
// âœ… æ¯æ¬¡ä»£ç å˜æ›´å¿…é¡»æ‰§è¡Œ
async function codeChangeWorkflow(changes: CodeChange[]) {
  // 1. å¼ºåˆ¶ä»£ç å®¡æŸ¥
  const reviewResult = await Mentor.review_code(changes);
  if (!reviewResult.approved) {
    throw new Error(`ä»£ç å®¡æŸ¥æœªé€šè¿‡: ${reviewResult.issues.join(', ')}`);
  }

  // 2. å¼ºåˆ¶æ¶æ„éªŒè¯
  const archValidation = await Mentor.validate_architecture(changes);
  if (!archValidation.compliant) {
    throw new Error(`æ¶æ„éªŒè¯å¤±è´¥: ${archValidation.violations.join(', ')}`);
  }

  // 3. å¼ºåˆ¶å®‰å…¨æ£€æŸ¥
  const securityCheck = await Mentor.security_audit(changes);
  if (securityCheck.vulnerabilities.length > 0) {
    throw new Error(`å‘ç°å®‰å…¨æ¼æ´: ${securityCheck.vulnerabilities.length}ä¸ª`);
  }

  // 4. å¼ºåˆ¶è´¨é‡æ£€æŸ¥
  const qualityCheck = await Mentor.quality_metrics(changes);
  if (qualityCheck.score < 90) {
    throw new Error(`ä»£ç è´¨é‡è¯„åˆ†è¿‡ä½: ${qualityCheck.score}/100`);
  }

  return { approved: true, metrics: qualityCheck };
}
```

## ğŸ”§ Serena ä»£ç è´¨é‡ç®¡ç†å¼ºåˆ¶ä½¿ç”¨

### å¿…é¡»ä½¿ç”¨çš„SerenaåŠŸèƒ½
```typescript
interface SerenaRequiredUsage {
  // ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆå¼ºåˆ¶ï¼‰
  qualityChecks: {
    "serena.code_review()": "å…¨é¢ä»£ç å®¡æŸ¥";
    "serena.style_check()": "ä»£ç é£æ ¼æ£€æŸ¥";
    "serena.complexity_check()": "å¤æ‚åº¦åˆ†æ";
    "serena.duplicate_check()": "é‡å¤ä»£ç æ£€æµ‹";
    "serena.naming_check()": "å‘½åè§„èŒƒæ£€æŸ¥";
  };

  // æµ‹è¯•ç®¡ç†ï¼ˆå¼ºåˆ¶ï¼‰
  testManagement: {
    "serena.test_coverage()": "æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥";
    "serena.test_generate()": "è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹";
    "serena.test_run()": "æ‰§è¡Œæµ‹è¯•å¥—ä»¶";
    "serena.benchmark_test()": "æ€§èƒ½åŸºå‡†æµ‹è¯•";
  };

  // å®‰å…¨æ£€æŸ¥ï¼ˆå¼ºåˆ¶ï¼‰
  securityChecks: {
    "serena.security_scan()": "å®‰å…¨æ¼æ´æ‰«æ";
    "serena.dependency_check()": "ä¾èµ–åŒ…å®‰å…¨æ£€æŸ¥";
    "serena.secret_scan()": "æ•æ„Ÿä¿¡æ¯æ‰«æ";
    "serena.permission_check()": "æƒé™æ£€æŸ¥";
  };

  // æ€§èƒ½åˆ†æï¼ˆå¼ºåˆ¶ï¼‰
  performanceAnalysis: {
    "serena.performance_analyze()": "æ€§èƒ½åˆ†æ";
    "serena.memory_profile()": "å†…å­˜åˆ†æ";
    "serena.bottleneck_detect()": "æ€§èƒ½ç“¶é¢ˆæ£€æµ‹";
    "serena.optimization_suggest()": "ä¼˜åŒ–å»ºè®®";
  };
}
```

### è´¨é‡é—¨ç¦å¼ºåˆ¶æ£€æŸ¥
```typescript
// âœ… æäº¤å‰å¼ºåˆ¶è´¨é‡æ£€æŸ¥
async function preCommitQualityGate(files: string[]) {
  console.log("ğŸ” æ‰§è¡Œå¼ºåˆ¶è´¨é‡æ£€æŸ¥...");

  // 1. ä»£ç é£æ ¼æ£€æŸ¥ï¼ˆå¼ºåˆ¶é€šè¿‡ï¼‰
  const styleResult = await serena.style_check(files);
  if (!styleResult.passed) {
    throw new Error(`ä»£ç é£æ ¼æ£€æŸ¥å¤±è´¥: ${styleResult.errors.length}ä¸ªé”™è¯¯`);
  }

  // 2. å¤æ‚åº¦æ£€æŸ¥ï¼ˆå¼ºåˆ¶é€šè¿‡ï¼‰
  const complexityResult = await serena.complexity_check(files);
  if (complexityResult.averageComplexity > 10) {
    throw new Error(`ä»£ç å¤æ‚åº¦è¿‡é«˜: ${complexityResult.averageComplexity}`);
  }

  // 3. å®‰å…¨æ‰«æï¼ˆå¼ºåˆ¶é€šè¿‡ï¼‰
  const securityResult = await serena.security_scan(files);
  if (securityResult.vulnerabilities.length > 0) {
    throw new Error(`å‘ç°å®‰å…¨æ¼æ´: ${securityResult.vulnerabilities.length}ä¸ª`);
  }

  // 4. æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥ï¼ˆå¼ºåˆ¶â‰¥85%ï¼‰
  const coverageResult = await serena.test_coverage(files);
  if (coverageResult.percentage < 85) {
    throw new Error(`æµ‹è¯•è¦†ç›–ç‡ä¸è¶³: ${coverageResult.percentage}% < 85%`);
  }

  console.log("âœ… æ‰€æœ‰è´¨é‡æ£€æŸ¥é€šè¿‡");
  return true;
}
```

## ğŸ§  Memory çŸ¥è¯†ç®¡ç†å¼ºåˆ¶ä½¿ç”¨

### å¼ºåˆ¶è®°å½•çš„ä¿¡æ¯ç±»å‹
```typescript
interface MemoryRequiredUsage {
  // è®¾è®¡å†³ç­–è®°å½•ï¼ˆå¼ºåˆ¶ï¼‰
  designDecisions: {
    "memory.store_decision()": "é‡è¦è®¾è®¡å†³ç­–å­˜å‚¨";
    "memory.retrieve_patterns()": "å†å²æ¨¡å¼æ£€ç´¢";
    "memory.analyze_trends()": "è¶‹åŠ¿åˆ†æ";
  };

  // é”™è¯¯ç»éªŒè®°å½•ï¼ˆå¼ºåˆ¶ï¼‰
  errorExperience: {
    "memory.record_failure()": "å¤±è´¥ç»éªŒè®°å½•";
    "memory.solution_mapping()": "è§£å†³æ–¹æ¡ˆæ˜ å°„";
    "memory.prevention_strategy()": "é¢„é˜²ç­–ç•¥å­˜å‚¨";
  };

  // æœ€ä½³å®è·µè®°å½•ï¼ˆå¼ºåˆ¶ï¼‰
  bestPractices: {
    "memory.store_practice()": "æœ€ä½³å®è·µå­˜å‚¨";
    "memory.context_mapping()": "ä¸Šä¸‹æ–‡æ˜ å°„";
    "memory.reuse_analysis()": "å¤ç”¨æ€§åˆ†æ";
  };
}
```

### å¼ºåˆ¶è®°å½•å·¥ä½œæµ
```typescript
// âœ… æ¯æ¬¡é‡è¦å·¥ä½œç»“æŸåå¼ºåˆ¶è®°å½•
async function recordWorkExperience(work: WorkSession) {
  // 1. è®°å½•è®¾è®¡å†³ç­–
  await memory.store_decision({
    type: "architecture_choice",
    decision: work.decisions,
    context: work.context,
    reasoning: work.reasoning,
    outcomes: work.outcomes
  });

  // 2. è®°å½•é‡åˆ°çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
  for (const issue of work.issues) {
    await memory.record_failure({
      problem: issue.description,
      solution: issue.solution,
      prevention: issue.preventionStrategy,
      tags: issue.tags
    });
  }

  // 3. è®°å½•å¯å¤ç”¨çš„æœ€ä½³å®è·µ
  await memory.store_practice({
    pattern: work.successfulPatterns,
    context: work.applicableContexts,
    benefits: work.benefits,
    limitations: work.limitations
  });
}
```

## ğŸ”„ Sequential Thinking ä¸ Context7 ååŒä½¿ç”¨

### é—®é¢˜åˆ†æå¼ºåˆ¶æµç¨‹
```typescript
// âœ… å¤æ‚é—®é¢˜å¿…é¡»ä½¿ç”¨Sequential Thinkingåˆ†è§£
async function solveComplexProblem(problem: ComplexProblem) {
  // 1. ä½¿ç”¨Sequential Thinkingåˆ†è§£é—®é¢˜
  const decomposition = await sequentialThinking.decompose({
    problem: problem.description,
    constraints: problem.constraints,
    goals: problem.goals
  });

  // 2. ä½¿ç”¨Context7è·å–ç›¸å…³æŠ€æœ¯æ–‡æ¡£
  const relevantDocs = await context7.search({
    query: problem.keywords,
    type: "technical_documentation",
    limit: 10
  });

  // 3. ç»“åˆå†å²ç»éªŒ
  const historicalSolutions = await memory.search({
    pattern: problem.pattern,
    context: problem.context
  });

  // 4. åˆ¶å®šåˆ†æ­¥è§£å†³æ–¹æ¡ˆ
  const solution = await sequentialThinking.synthesize({
    subProblems: decomposition.subProblems,
    resources: relevantDocs,
    experience: historicalSolutions
  });

  return solution;
}
```

## âš ï¸ è¿è§„å¤„ç†æœºåˆ¶

### å¼ºåˆ¶ä¸­æ–­æ¡ä»¶
1. **ç»•è¿‡Mentorä»£ç å®¡æŸ¥**: ç«‹å³ä¸­æ–­å·¥ä½œæµç¨‹
2. **è·³è¿‡Serenaè´¨é‡æ£€æŸ¥**: æ‹’ç»ä»£ç æäº¤
3. **æœªä½¿ç”¨TaskManagerè°ƒåº¦**: å·¥ä½œæ— æ•ˆåŒ–
4. **æœªè®°å½•åˆ°Memory**: ç»éªŒæ— æ³•ç§¯ç´¯ï¼Œå½±å“è¯„ä¼°

### åˆè§„æ€§æ£€æŸ¥
```typescript
// âœ… å·¥ä½œå¼€å§‹å‰çš„åˆè§„æ€§æ£€æŸ¥
async function complianceCheck(workPlan: WorkPlan) {
  const checks = [
    TaskManager.isAvailable(),
    Mentor.isConfigured(),
    serena.isActive(),
    memory.isAccessible(),
    sequentialThinking.isReady(),
    context7.isConnected()
  ];

  const results = await Promise.all(checks);
  const failedTools = results
    .map((result, index) => ({ result, tool: TOOL_NAMES[index] }))
    .filter(({ result }) => !result)
    .map(({ tool }) => tool);

  if (failedTools.length > 0) {
    throw new Error(`MCPå·¥å…·æœªå°±ç»ª: ${failedTools.join(', ')}`);
  }

  console.log("âœ… æ‰€æœ‰MCPå·¥å…·å°±ç»ªï¼Œå¯ä»¥å¼€å§‹å·¥ä½œ");
  return true;
}
```

---

**å‚è€ƒæ–‡æ¡£**:
- [MCPå·¥å…·æŒ‡å¯¼é’©å­](.kiro/hooks/mcp-tools-guidance.kiro.hook)
- [å·¥ä½œè´¨é‡ä¿è¯é’©å­](.kiro/hooks/work-quality-assurance.kiro.hook)
- [å¼€å‘å·¥ä½œæµç¨‹å¢å¼ºé’©å­](.kiro/hooks/development-workflow-enhancement.kiro.hook)
