---
alwaysApply: true
---

# ZK-Agent è‡ªç ”æ™ºèƒ½ä½“æ¶æ„è§„èŒƒ

## ğŸ“‹ è‡ªç ”æ™ºèƒ½ä½“æ¦‚è¿°

åŸºäº [è‡ªç ”æ™ºèƒ½ä½“æŠ€æœ¯æŒ‡å¯¼](.kiro/steering/self-developed-agents.md) å’Œ [é¡¹ç›®æ¶æ„è§„èŒƒ](.cursor/rules/01-project-architecture.mdc)ï¼ŒZK-Agentå¹³å°åŒ…å«ä¸¤ä¸ªæ ¸å¿ƒçš„è‡ªç ”æ™ºèƒ½ä½“ã€‚

### æ ¸å¿ƒç‰¹æ€§
- **æ“ä½œå¼æ™ºèƒ½ä½“**: éçº¯å¯¹è¯ï¼Œå…·å¤‡å®é™…æ“ä½œèƒ½åŠ›
- **AG-UIåè®®é›†æˆ**: é€šè¿‡CopilotKit + AG-UIåè®®ç»Ÿä¸€å¯¹è¯å¼æ“ä½œæ§åˆ¶
- **è®¡ç®—å¯†é›†å‹ä¼˜åŒ–**: é’ˆå¯¹GPUåŠ é€Ÿã€å†…å­˜æ± ç®¡ç†ã€æµå¼å¤„ç†ä¼˜åŒ–
- **å¾®æœåŠ¡æ¶æ„**: åŸºäºæ¸è¿›å¼å¾®æœåŠ¡æ¶æ„è®¾è®¡

## ğŸ”§ CADè§£è¯»æ™ºèƒ½ä½“

### æ ¸å¿ƒåŠŸèƒ½æ¶æ„
```typescript
interface CADAgentCapabilities {
  fileFormats: ["DWG", "DXF", "STEP", "IGES", "STL", "OBJ"];
  rendering: {
    engine: "Three.js + WebGL";
    features: ["å®æ—¶3Dæ¸²æŸ“", "äº¤äº’å¼æŸ¥çœ‹", "å¤šè§†è§’å±•ç¤º"];
  };
  analysis: {
    geometry: "å‡ ä½•åˆ†æã€å°ºå¯¸æµ‹é‡";
    materials: "ææ–™å±æ€§åˆ†æ";
    assembly: "è£…é…å…³ç³»è§£æ";
  };
  reporting: {
    formats: ["PDF", "JSON", "XML"];
    autoGeneration: "è‡ªåŠ¨ç”ŸæˆæŠ€æœ¯æŠ¥å‘Š";
  };
}
```

### ç›®å½•ç»“æ„æ ‡å‡†
```
app/cad-analyzer/
â”œâ”€â”€ page.tsx                    # ä¸»é¡µé¢
â”œâ”€â”€ layout.tsx                  # å¸ƒå±€ç»„ä»¶
â”œâ”€â”€ upload/                     # æ–‡ä»¶ä¸Šä¼ æ¨¡å—
â”œâ”€â”€ viewer/                     # 3DæŸ¥çœ‹å™¨æ¨¡å—
â”œâ”€â”€ analysis/                   # åˆ†æé¢æ¿æ¨¡å—
â””â”€â”€ copilot/                    # å¯¹è¯æ§åˆ¶æ¨¡å—

components/cad/
â”œâ”€â”€ file-uploader.tsx           # æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
â”œâ”€â”€ model-viewer.tsx            # 3Dæ¨¡å‹æŸ¥çœ‹å™¨
â”œâ”€â”€ analysis-panel.tsx          # åˆ†æé¢æ¿
â”œâ”€â”€ measurement-tools.tsx       # æµ‹é‡å·¥å…·
â”œâ”€â”€ material-inspector.tsx      # ææ–™æ£€æŸ¥å™¨
â”œâ”€â”€ assembly-tree.tsx           # è£…é…æ ‘ç»„ä»¶
â””â”€â”€ report-generator.tsx        # æŠ¥å‘Šç”Ÿæˆå™¨

lib/cad/
â”œâ”€â”€ parsers/                    # æ–‡ä»¶è§£æå™¨
â”‚   â”œâ”€â”€ dwg-parser.ts          # DWGæ ¼å¼è§£æ
â”‚   â”œâ”€â”€ step-parser.ts         # STEPæ ¼å¼è§£æ
â”‚   â””â”€â”€ base-parser.ts         # åŸºç¡€è§£æå™¨
â”œâ”€â”€ renderers/                  # æ¸²æŸ“å¼•æ“
â”‚   â”œâ”€â”€ three-renderer.ts      # Three.jsæ¸²æŸ“
â”‚   â””â”€â”€ webgl-renderer.ts      # WebGLæ¸²æŸ“
â”œâ”€â”€ analyzers/                  # åˆ†æå¼•æ“
â”‚   â”œâ”€â”€ geometry-analyzer.ts   # å‡ ä½•åˆ†æ
â”‚   â”œâ”€â”€ material-analyzer.ts   # ææ–™åˆ†æ
â”‚   â””â”€â”€ assembly-analyzer.ts   # è£…é…åˆ†æ
â””â”€â”€ exporters/                  # å¯¼å‡ºå™¨
    â”œâ”€â”€ pdf-exporter.ts        # PDFå¯¼å‡º
    â””â”€â”€ json-exporter.ts       # JSONå¯¼å‡º
```

### CADè§£æå™¨å®ç°æ ‡å‡†
```typescript
/**
 * CADæ–‡ä»¶è§£æå™¨åŸºç±»
 *
 * å®šä¹‰äº†æ‰€æœ‰CADè§£æå™¨çš„ç»Ÿä¸€æ¥å£å’ŒåŸºç¡€åŠŸèƒ½
 */
export abstract class BaseCADParser {
  /**
   * è§£æCADæ–‡ä»¶
   *
   * @param file - å¾…è§£æçš„CADæ–‡ä»¶
   * @param options - è§£æé€‰é¡¹é…ç½®
   * @returns Promise<CADModel> - è§£æåçš„3Dæ¨¡å‹æ•°æ®
   *
   * @throws CADParseError - å½“æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒæˆ–è§£æå¤±è´¥æ—¶æŠ›å‡º
   *
   * @example
   * ```typescript
   * const parser = new DWGParser();
   * const model = await parser.parse(file, { precision: 'high' });
   * ```
   */
  abstract parse(file: File, options?: ParseOptions): Promise<CADModel>;

  /**
   * éªŒè¯æ–‡ä»¶æ ¼å¼
   *
   * @param file - å¾…éªŒè¯çš„æ–‡ä»¶
   * @returns boolean - æ˜¯å¦æ”¯æŒè¯¥æ ¼å¼
   */
  abstract validateFormat(file: File): boolean;

  /**
   * è·å–æ”¯æŒçš„æ–‡ä»¶æ‰©å±•å
   *
   * @returns string[] - æ”¯æŒçš„æ‰©å±•ååˆ—è¡¨
   */
  abstract getSupportedExtensions(): string[];
}

/**
 * DWGæ–‡ä»¶è§£æå™¨
 */
export class DWGParser extends BaseCADParser {
  async parse(file: File, options: ParseOptions = {}): Promise<CADModel> {
    try {
      // éªŒè¯æ–‡ä»¶æ ¼å¼
      if (!this.validateFormat(file)) {
        throw new CADParseError('ä¸æ”¯æŒçš„DWGæ–‡ä»¶æ ¼å¼');
      }

      // è¯»å–æ–‡ä»¶æ•°æ®
      const buffer = await file.arrayBuffer();

      // è§£æDWGæ•°æ®ç»“æ„
      const dwgData = await this.parseDWGStructure(buffer);

      // è½¬æ¢ä¸ºæ ‡å‡†3Dæ¨¡å‹
      const model = this.convertToCADModel(dwgData, options);

      return model;
    } catch (error) {
      throw new CADParseError(`DWGè§£æå¤±è´¥: ${error.message}`);
    }
  }

  validateFormat(file: File): boolean {
    return file.name.toLowerCase().endsWith('.dwg');
  }

  getSupportedExtensions(): string[] {
    return ['.dwg'];
  }
}
```

## ğŸ¨ æµ·æŠ¥ç”Ÿæˆæ™ºèƒ½ä½“

### æ ¸å¿ƒåŠŸèƒ½æ¶æ„
```typescript
interface PosterAgentCapabilities {
  templates: {
    categories: ["å•†ä¸š", "æ•™è‚²", "æ´»åŠ¨", "äº§å“", "ç¤¾äº¤"];
    customization: "å®Œå…¨å¯å®šåˆ¶åŒ–";
  };
  aiGeneration: {
    textGeneration: "åŸºäºæç¤ºè¯ç”Ÿæˆæ–‡æ¡ˆ";
    imageGeneration: "AIå›¾åƒç”Ÿæˆå’Œç¼–è¾‘";
    layoutOptimization: "æ™ºèƒ½å¸ƒå±€ä¼˜åŒ–";
  };
  export: {
    formats: ["PNG", "JPG", "PDF", "SVG"];
    resolutions: ["Web", "Print", "Social"];
  };
}
```

### æµ·æŠ¥ç”Ÿæˆå™¨å®ç°æ ‡å‡†
```typescript
/**
 * æµ·æŠ¥ç”Ÿæˆå¼•æ“
 *
 * è´Ÿè´£æµ·æŠ¥çš„è®¾è®¡ã€ç”Ÿæˆå’Œå¯¼å‡ºåŠŸèƒ½
 */
export class PosterGenerationEngine {
  private aiTextGenerator: AITextGenerator;
  private imageProcessor: ImageProcessor;
  private layoutEngine: LayoutEngine;

  constructor() {
    this.aiTextGenerator = new AITextGenerator();
    this.imageProcessor = new ImageProcessor();
    this.layoutEngine = new LayoutEngine();
  }

  /**
   * ç”Ÿæˆæµ·æŠ¥
   *
   * @param requirements - æµ·æŠ¥éœ€æ±‚æè¿°
   * @param template - ä½¿ç”¨çš„æ¨¡æ¿
   * @param options - ç”Ÿæˆé€‰é¡¹
   * @returns Promise<PosterResult> - ç”Ÿæˆçš„æµ·æŠ¥æ•°æ®
   *
   * @example
   * ```typescript
   * const engine = new PosterGenerationEngine();
   * const poster = await engine.generatePoster({
   *   theme: "ç§‘æŠ€äº§å“å‘å¸ƒ",
   *   style: "ç°ä»£ç®€çº¦",
   *   size: "A4"
   * }, template);
   * ```
   */
  async generatePoster(
    requirements: PosterRequirements,
    template: PosterTemplate,
    options: GenerationOptions = {}
  ): Promise<PosterResult> {
    try {
      // ä½¿ç”¨AIç”Ÿæˆæ–‡æ¡ˆå†…å®¹
      const content = await this.aiTextGenerator.generateContent(requirements);

      // ç”Ÿæˆæˆ–å¤„ç†å›¾åƒ
      const images = await this.imageProcessor.processImages(
        requirements.images,
        options.imageStyle
      );

      // æ™ºèƒ½å¸ƒå±€ä¼˜åŒ–
      const layout = await this.layoutEngine.optimizeLayout(
        template,
        content,
        images,
        requirements.size
      );

      // æ¸²æŸ“æœ€ç»ˆæµ·æŠ¥
      const posterData = await this.renderPoster(layout);

      return {
        success: true,
        posterData,
        metadata: {
          template: template.id,
          generationTime: Date.now(),
          aiGenerated: true
        }
      };
    } catch (error) {
      throw new PosterGenerationError(`æµ·æŠ¥ç”Ÿæˆå¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å¯¼å‡ºæµ·æŠ¥
   *
   * @param poster - æµ·æŠ¥æ•°æ®
   * @param format - å¯¼å‡ºæ ¼å¼
   * @param quality - å¯¼å‡ºè´¨é‡
   * @returns Promise<Blob> - å¯¼å‡ºçš„æ–‡ä»¶æ•°æ®
   */
  async exportPoster(
    poster: PosterData,
    format: ExportFormat,
    quality: ExportQuality = 'high'
  ): Promise<Blob> {
    try {
      const exporter = this.getExporter(format);
      return await exporter.export(poster, quality);
    } catch (error) {
      throw new PosterExportError(`æµ·æŠ¥å¯¼å‡ºå¤±è´¥: ${error.message}`);
    }
  }
}
```

## ğŸ”„ AG-UIåè®®é›†æˆ

### CopilotKité›†æˆæ ‡å‡†
```typescript
/**
 * è‡ªç ”æ™ºèƒ½ä½“çš„AG-UIåè®®é€‚é…å™¨
 */
export class SelfDevelopedAgentAdapter {
  /**
   * CADæ™ºèƒ½ä½“å¯¹è¯æ§åˆ¶
   */
  async handleCADConversation(
    message: string,
    context: CADContext
  ): Promise<AgentResponse> {
    // è§£æç”¨æˆ·æ„å›¾
    const intent = await this.parseUserIntent(message, 'cad');

    switch (intent.action) {
      case 'upload_file':
        return this.handleFileUpload(intent.parameters);
      case 'analyze_model':
        return this.handleModelAnalysis(intent.parameters, context);
      case 'generate_report':
        return this.handleReportGeneration(intent.parameters, context);
      default:
        return this.handleGeneralCADQuery(message, context);
    }
  }

  /**
   * æµ·æŠ¥æ™ºèƒ½ä½“å¯¹è¯æ§åˆ¶
   */
  async handlePosterConversation(
    message: string,
    context: PosterContext
  ): Promise<AgentResponse> {
    const intent = await this.parseUserIntent(message, 'poster');

    switch (intent.action) {
      case 'create_poster':
        return this.handlePosterCreation(intent.parameters);
      case 'modify_design':
        return this.handleDesignModification(intent.parameters, context);
      case 'export_poster':
        return this.handlePosterExport(intent.parameters, context);
      default:
        return this.handleGeneralPosterQuery(message, context);
    }
  }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è¦æ±‚

### GPUåŠ é€Ÿä¼˜åŒ–
```typescript
/**
 * GPUåŠ é€Ÿç®¡ç†å™¨
 */
export class GPUAccelerationManager {
  /**
   * CADæ¨¡å‹æ¸²æŸ“åŠ é€Ÿ
   */
  async accelerateCADRendering(model: CADModel): Promise<void> {
    // ä½¿ç”¨WebGLè¿›è¡ŒGPUåŠ é€Ÿæ¸²æŸ“
    // å®ç°å‡ ä½•ä½“ç¼“å­˜å’ŒLODä¼˜åŒ–
  }

  /**
   * æµ·æŠ¥ç”ŸæˆåŠ é€Ÿ
   */
  async acceleratePosterGeneration(requirements: PosterRequirements): Promise<void> {
    // ä½¿ç”¨GPUåŠ é€Ÿå›¾åƒå¤„ç†
    // å®ç°å¹¶è¡Œæ–‡æ¡ˆç”Ÿæˆ
  }
}
```

### å†…å­˜æ± ç®¡ç†
```typescript
/**
 * å†…å­˜æ± ç®¡ç†å™¨
 */
export class MemoryPoolManager {
  private cadModelPool: Map<string, CADModel> = new Map();
  private posterTemplatePool: Map<string, PosterTemplate> = new Map();

  /**
   * CADæ¨¡å‹ç¼“å­˜ç®¡ç†
   */
  async cacheCADModel(modelId: string, model: CADModel): Promise<void> {
    // å®ç°æ™ºèƒ½ç¼“å­˜ç­–ç•¥
    // åŸºäºæ–‡ä»¶å¤§å°å’Œè®¿é—®é¢‘ç‡ä¼˜åŒ–
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  async cleanupExpiredCache(): Promise<void> {
    // å®šæœŸæ¸…ç†ä¸å†ä½¿ç”¨çš„æ¨¡å‹æ•°æ®
  }
}
```

## âš ï¸ å¼€å‘çº¦æŸ

### å¼ºåˆ¶è¦æ±‚
1. **AG-UIåè®®**: æ‰€æœ‰æ™ºèƒ½ä½“å¿…é¡»æ”¯æŒAG-UIåè®®
2. **CopilotKité›†æˆ**: å¿…é¡»é€šè¿‡CopilotKitå®ç°å¯¹è¯æ§åˆ¶
3. **æ€§èƒ½ä¼˜åŒ–**: å¿…é¡»å®ç°GPUåŠ é€Ÿå’Œå†…å­˜æ± ç®¡ç†
4. **ç±»å‹å®‰å…¨**: æ‰€æœ‰æ¥å£å¿…é¡»æœ‰å®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰
5. **é”™è¯¯å¤„ç†**: å¿…é¡»æœ‰å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œé”™è¯¯æ¢å¤æœºåˆ¶

### æœ€ä½³å®è·µ
1. **æ¨¡å—åŒ–è®¾è®¡**: è§£æå™¨ã€æ¸²æŸ“å™¨ã€åˆ†æå™¨ç‹¬ç«‹å¼€å‘
2. **ç¼“å­˜ç­–ç•¥**: åˆç†ä½¿ç”¨å†…å­˜ç¼“å­˜æå‡æ€§èƒ½
3. **æµå¼å¤„ç†**: å¤§æ–‡ä»¶å¤„ç†å¿…é¡»æ”¯æŒæµå¼æ“ä½œ
4. **ç”¨æˆ·ä½“éªŒ**: æä¾›å®æ—¶è¿›åº¦åé¦ˆå’Œé”™è¯¯æç¤º

---

**å‚è€ƒæ–‡æ¡£**:
- [è‡ªç ”æ™ºèƒ½ä½“æŠ€æœ¯æŒ‡å¯¼](.kiro/steering/self-developed-agents.md)
- [é¡¹ç›®æ¶æ„è§„èŒƒ](.cursor/rules/01-project-architecture.mdc)
- [æŠ€æœ¯æ ˆå’ŒAIæ¨¡å‹ç®¡ç†è§„èŒƒ](.cursor/rules/08-tech-stack-ai-models.mdc)
- [APIè®¾è®¡æ ‡å‡†](.cursor/rules/06-api-design-standards.mdc)
# ZK-Agent è‡ªç ”æ™ºèƒ½ä½“æ¶æ„è§„èŒƒ

## ğŸ“‹ è‡ªç ”æ™ºèƒ½ä½“æ¦‚è¿°

åŸºäº [è‡ªç ”æ™ºèƒ½ä½“æŠ€æœ¯æŒ‡å¯¼](.kiro/steering/self-developed-agents.md) å’Œ [é¡¹ç›®æ¶æ„è§„èŒƒ](.cursor/rules/01-project-architecture.mdc)ï¼ŒZK-Agentå¹³å°åŒ…å«ä¸¤ä¸ªæ ¸å¿ƒçš„è‡ªç ”æ™ºèƒ½ä½“ã€‚

### æ ¸å¿ƒç‰¹æ€§
- **æ“ä½œå¼æ™ºèƒ½ä½“**: éçº¯å¯¹è¯ï¼Œå…·å¤‡å®é™…æ“ä½œèƒ½åŠ›
- **AG-UIåè®®é›†æˆ**: é€šè¿‡CopilotKit + AG-UIåè®®ç»Ÿä¸€å¯¹è¯å¼æ“ä½œæ§åˆ¶
- **è®¡ç®—å¯†é›†å‹ä¼˜åŒ–**: é’ˆå¯¹GPUåŠ é€Ÿã€å†…å­˜æ± ç®¡ç†ã€æµå¼å¤„ç†ä¼˜åŒ–
- **å¾®æœåŠ¡æ¶æ„**: åŸºäºæ¸è¿›å¼å¾®æœåŠ¡æ¶æ„è®¾è®¡

## ğŸ”§ CADè§£è¯»æ™ºèƒ½ä½“

### æ ¸å¿ƒåŠŸèƒ½æ¶æ„
```typescript
interface CADAgentCapabilities {
  fileFormats: ["DWG", "DXF", "STEP", "IGES", "STL", "OBJ"];
  rendering: {
    engine: "Three.js + WebGL";
    features: ["å®æ—¶3Dæ¸²æŸ“", "äº¤äº’å¼æŸ¥çœ‹", "å¤šè§†è§’å±•ç¤º"];
  };
  analysis: {
    geometry: "å‡ ä½•åˆ†æã€å°ºå¯¸æµ‹é‡";
    materials: "ææ–™å±æ€§åˆ†æ";
    assembly: "è£…é…å…³ç³»è§£æ";
  };
  reporting: {
    formats: ["PDF", "JSON", "XML"];
    autoGeneration: "è‡ªåŠ¨ç”ŸæˆæŠ€æœ¯æŠ¥å‘Š";
  };
}
```

### ç›®å½•ç»“æ„æ ‡å‡†
```
app/cad-analyzer/
â”œâ”€â”€ page.tsx                    # ä¸»é¡µé¢
â”œâ”€â”€ layout.tsx                  # å¸ƒå±€ç»„ä»¶
â”œâ”€â”€ upload/                     # æ–‡ä»¶ä¸Šä¼ æ¨¡å—
â”œâ”€â”€ viewer/                     # 3DæŸ¥çœ‹å™¨æ¨¡å—
â”œâ”€â”€ analysis/                   # åˆ†æé¢æ¿æ¨¡å—
â””â”€â”€ copilot/                    # å¯¹è¯æ§åˆ¶æ¨¡å—

components/cad/
â”œâ”€â”€ file-uploader.tsx           # æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
â”œâ”€â”€ model-viewer.tsx            # 3Dæ¨¡å‹æŸ¥çœ‹å™¨
â”œâ”€â”€ analysis-panel.tsx          # åˆ†æé¢æ¿
â”œâ”€â”€ measurement-tools.tsx       # æµ‹é‡å·¥å…·
â”œâ”€â”€ material-inspector.tsx      # ææ–™æ£€æŸ¥å™¨
â”œâ”€â”€ assembly-tree.tsx           # è£…é…æ ‘ç»„ä»¶
â””â”€â”€ report-generator.tsx        # æŠ¥å‘Šç”Ÿæˆå™¨

lib/cad/
â”œâ”€â”€ parsers/                    # æ–‡ä»¶è§£æå™¨
â”‚   â”œâ”€â”€ dwg-parser.ts          # DWGæ ¼å¼è§£æ
â”‚   â”œâ”€â”€ step-parser.ts         # STEPæ ¼å¼è§£æ
â”‚   â””â”€â”€ base-parser.ts         # åŸºç¡€è§£æå™¨
â”œâ”€â”€ renderers/                  # æ¸²æŸ“å¼•æ“
â”‚   â”œâ”€â”€ three-renderer.ts      # Three.jsæ¸²æŸ“
â”‚   â””â”€â”€ webgl-renderer.ts      # WebGLæ¸²æŸ“
â”œâ”€â”€ analyzers/                  # åˆ†æå¼•æ“
â”‚   â”œâ”€â”€ geometry-analyzer.ts   # å‡ ä½•åˆ†æ
â”‚   â”œâ”€â”€ material-analyzer.ts   # ææ–™åˆ†æ
â”‚   â””â”€â”€ assembly-analyzer.ts   # è£…é…åˆ†æ
â””â”€â”€ exporters/                  # å¯¼å‡ºå™¨
    â”œâ”€â”€ pdf-exporter.ts        # PDFå¯¼å‡º
    â””â”€â”€ json-exporter.ts       # JSONå¯¼å‡º
```

### CADè§£æå™¨å®ç°æ ‡å‡†
```typescript
/**
 * CADæ–‡ä»¶è§£æå™¨åŸºç±»
 *
 * å®šä¹‰äº†æ‰€æœ‰CADè§£æå™¨çš„ç»Ÿä¸€æ¥å£å’ŒåŸºç¡€åŠŸèƒ½
 */
export abstract class BaseCADParser {
  /**
   * è§£æCADæ–‡ä»¶
   *
   * @param file - å¾…è§£æçš„CADæ–‡ä»¶
   * @param options - è§£æé€‰é¡¹é…ç½®
   * @returns Promise<CADModel> - è§£æåçš„3Dæ¨¡å‹æ•°æ®
   *
   * @throws CADParseError - å½“æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒæˆ–è§£æå¤±è´¥æ—¶æŠ›å‡º
   *
   * @example
   * ```typescript
   * const parser = new DWGParser();
   * const model = await parser.parse(file, { precision: 'high' });
   * ```
   */
  abstract parse(file: File, options?: ParseOptions): Promise<CADModel>;

  /**
   * éªŒè¯æ–‡ä»¶æ ¼å¼
   *
   * @param file - å¾…éªŒè¯çš„æ–‡ä»¶
   * @returns boolean - æ˜¯å¦æ”¯æŒè¯¥æ ¼å¼
   */
  abstract validateFormat(file: File): boolean;

  /**
   * è·å–æ”¯æŒçš„æ–‡ä»¶æ‰©å±•å
   *
   * @returns string[] - æ”¯æŒçš„æ‰©å±•ååˆ—è¡¨
   */
  abstract getSupportedExtensions(): string[];
}

/**
 * DWGæ–‡ä»¶è§£æå™¨
 */
export class DWGParser extends BaseCADParser {
  async parse(file: File, options: ParseOptions = {}): Promise<CADModel> {
    try {
      // éªŒè¯æ–‡ä»¶æ ¼å¼
      if (!this.validateFormat(file)) {
        throw new CADParseError('ä¸æ”¯æŒçš„DWGæ–‡ä»¶æ ¼å¼');
      }

      // è¯»å–æ–‡ä»¶æ•°æ®
      const buffer = await file.arrayBuffer();

      // è§£æDWGæ•°æ®ç»“æ„
      const dwgData = await this.parseDWGStructure(buffer);

      // è½¬æ¢ä¸ºæ ‡å‡†3Dæ¨¡å‹
      const model = this.convertToCADModel(dwgData, options);

      return model;
    } catch (error) {
      throw new CADParseError(`DWGè§£æå¤±è´¥: ${error.message}`);
    }
  }

  validateFormat(file: File): boolean {
    return file.name.toLowerCase().endsWith('.dwg');
  }

  getSupportedExtensions(): string[] {
    return ['.dwg'];
  }
}
```

## ğŸ¨ æµ·æŠ¥ç”Ÿæˆæ™ºèƒ½ä½“

### æ ¸å¿ƒåŠŸèƒ½æ¶æ„
```typescript
interface PosterAgentCapabilities {
  templates: {
    categories: ["å•†ä¸š", "æ•™è‚²", "æ´»åŠ¨", "äº§å“", "ç¤¾äº¤"];
    customization: "å®Œå…¨å¯å®šåˆ¶åŒ–";
  };
  aiGeneration: {
    textGeneration: "åŸºäºæç¤ºè¯ç”Ÿæˆæ–‡æ¡ˆ";
    imageGeneration: "AIå›¾åƒç”Ÿæˆå’Œç¼–è¾‘";
    layoutOptimization: "æ™ºèƒ½å¸ƒå±€ä¼˜åŒ–";
  };
  export: {
    formats: ["PNG", "JPG", "PDF", "SVG"];
    resolutions: ["Web", "Print", "Social"];
  };
}
```

### æµ·æŠ¥ç”Ÿæˆå™¨å®ç°æ ‡å‡†
```typescript
/**
 * æµ·æŠ¥ç”Ÿæˆå¼•æ“
 *
 * è´Ÿè´£æµ·æŠ¥çš„è®¾è®¡ã€ç”Ÿæˆå’Œå¯¼å‡ºåŠŸèƒ½
 */
export class PosterGenerationEngine {
  private aiTextGenerator: AITextGenerator;
  private imageProcessor: ImageProcessor;
  private layoutEngine: LayoutEngine;

  constructor() {
    this.aiTextGenerator = new AITextGenerator();
    this.imageProcessor = new ImageProcessor();
    this.layoutEngine = new LayoutEngine();
  }

  /**
   * ç”Ÿæˆæµ·æŠ¥
   *
   * @param requirements - æµ·æŠ¥éœ€æ±‚æè¿°
   * @param template - ä½¿ç”¨çš„æ¨¡æ¿
   * @param options - ç”Ÿæˆé€‰é¡¹
   * @returns Promise<PosterResult> - ç”Ÿæˆçš„æµ·æŠ¥æ•°æ®
   *
   * @example
   * ```typescript
   * const engine = new PosterGenerationEngine();
   * const poster = await engine.generatePoster({
   *   theme: "ç§‘æŠ€äº§å“å‘å¸ƒ",
   *   style: "ç°ä»£ç®€çº¦",
   *   size: "A4"
   * }, template);
   * ```
   */
  async generatePoster(
    requirements: PosterRequirements,
    template: PosterTemplate,
    options: GenerationOptions = {}
  ): Promise<PosterResult> {
    try {
      // ä½¿ç”¨AIç”Ÿæˆæ–‡æ¡ˆå†…å®¹
      const content = await this.aiTextGenerator.generateContent(requirements);

      // ç”Ÿæˆæˆ–å¤„ç†å›¾åƒ
      const images = await this.imageProcessor.processImages(
        requirements.images,
        options.imageStyle
      );

      // æ™ºèƒ½å¸ƒå±€ä¼˜åŒ–
      const layout = await this.layoutEngine.optimizeLayout(
        template,
        content,
        images,
        requirements.size
      );

      // æ¸²æŸ“æœ€ç»ˆæµ·æŠ¥
      const posterData = await this.renderPoster(layout);

      return {
        success: true,
        posterData,
        metadata: {
          template: template.id,
          generationTime: Date.now(),
          aiGenerated: true
        }
      };
    } catch (error) {
      throw new PosterGenerationError(`æµ·æŠ¥ç”Ÿæˆå¤±è´¥: ${error.message}`);
    }
  }

  /**
   * å¯¼å‡ºæµ·æŠ¥
   *
   * @param poster - æµ·æŠ¥æ•°æ®
   * @param format - å¯¼å‡ºæ ¼å¼
   * @param quality - å¯¼å‡ºè´¨é‡
   * @returns Promise<Blob> - å¯¼å‡ºçš„æ–‡ä»¶æ•°æ®
   */
  async exportPoster(
    poster: PosterData,
    format: ExportFormat,
    quality: ExportQuality = 'high'
  ): Promise<Blob> {
    try {
      const exporter = this.getExporter(format);
      return await exporter.export(poster, quality);
    } catch (error) {
      throw new PosterExportError(`æµ·æŠ¥å¯¼å‡ºå¤±è´¥: ${error.message}`);
    }
  }
}
```

## ğŸ”„ AG-UIåè®®é›†æˆ

### CopilotKité›†æˆæ ‡å‡†
```typescript
/**
 * è‡ªç ”æ™ºèƒ½ä½“çš„AG-UIåè®®é€‚é…å™¨
 */
export class SelfDevelopedAgentAdapter {
  /**
   * CADæ™ºèƒ½ä½“å¯¹è¯æ§åˆ¶
   */
  async handleCADConversation(
    message: string,
    context: CADContext
  ): Promise<AgentResponse> {
    // è§£æç”¨æˆ·æ„å›¾
    const intent = await this.parseUserIntent(message, 'cad');

    switch (intent.action) {
      case 'upload_file':
        return this.handleFileUpload(intent.parameters);
      case 'analyze_model':
        return this.handleModelAnalysis(intent.parameters, context);
      case 'generate_report':
        return this.handleReportGeneration(intent.parameters, context);
      default:
        return this.handleGeneralCADQuery(message, context);
    }
  }

  /**
   * æµ·æŠ¥æ™ºèƒ½ä½“å¯¹è¯æ§åˆ¶
   */
  async handlePosterConversation(
    message: string,
    context: PosterContext
  ): Promise<AgentResponse> {
    const intent = await this.parseUserIntent(message, 'poster');

    switch (intent.action) {
      case 'create_poster':
        return this.handlePosterCreation(intent.parameters);
      case 'modify_design':
        return this.handleDesignModification(intent.parameters, context);
      case 'export_poster':
        return this.handlePosterExport(intent.parameters, context);
      default:
        return this.handleGeneralPosterQuery(message, context);
    }
  }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è¦æ±‚

### GPUåŠ é€Ÿä¼˜åŒ–
```typescript
/**
 * GPUåŠ é€Ÿç®¡ç†å™¨
 */
export class GPUAccelerationManager {
  /**
   * CADæ¨¡å‹æ¸²æŸ“åŠ é€Ÿ
   */
  async accelerateCADRendering(model: CADModel): Promise<void> {
    // ä½¿ç”¨WebGLè¿›è¡ŒGPUåŠ é€Ÿæ¸²æŸ“
    // å®ç°å‡ ä½•ä½“ç¼“å­˜å’ŒLODä¼˜åŒ–
  }

  /**
   * æµ·æŠ¥ç”ŸæˆåŠ é€Ÿ
   */
  async acceleratePosterGeneration(requirements: PosterRequirements): Promise<void> {
    // ä½¿ç”¨GPUåŠ é€Ÿå›¾åƒå¤„ç†
    // å®ç°å¹¶è¡Œæ–‡æ¡ˆç”Ÿæˆ
  }
}
```

### å†…å­˜æ± ç®¡ç†
```typescript
/**
 * å†…å­˜æ± ç®¡ç†å™¨
 */
export class MemoryPoolManager {
  private cadModelPool: Map<string, CADModel> = new Map();
  private posterTemplatePool: Map<string, PosterTemplate> = new Map();

  /**
   * CADæ¨¡å‹ç¼“å­˜ç®¡ç†
   */
  async cacheCADModel(modelId: string, model: CADModel): Promise<void> {
    // å®ç°æ™ºèƒ½ç¼“å­˜ç­–ç•¥
    // åŸºäºæ–‡ä»¶å¤§å°å’Œè®¿é—®é¢‘ç‡ä¼˜åŒ–
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  async cleanupExpiredCache(): Promise<void> {
    // å®šæœŸæ¸…ç†ä¸å†ä½¿ç”¨çš„æ¨¡å‹æ•°æ®
  }
}
```

## âš ï¸ å¼€å‘çº¦æŸ

### å¼ºåˆ¶è¦æ±‚
1. **AG-UIåè®®**: æ‰€æœ‰æ™ºèƒ½ä½“å¿…é¡»æ”¯æŒAG-UIåè®®
2. **CopilotKité›†æˆ**: å¿…é¡»é€šè¿‡CopilotKitå®ç°å¯¹è¯æ§åˆ¶
3. **æ€§èƒ½ä¼˜åŒ–**: å¿…é¡»å®ç°GPUåŠ é€Ÿå’Œå†…å­˜æ± ç®¡ç†
4. **ç±»å‹å®‰å…¨**: æ‰€æœ‰æ¥å£å¿…é¡»æœ‰å®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰
5. **é”™è¯¯å¤„ç†**: å¿…é¡»æœ‰å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œé”™è¯¯æ¢å¤æœºåˆ¶

### æœ€ä½³å®è·µ
1. **æ¨¡å—åŒ–è®¾è®¡**: è§£æå™¨ã€æ¸²æŸ“å™¨ã€åˆ†æå™¨ç‹¬ç«‹å¼€å‘
2. **ç¼“å­˜ç­–ç•¥**: åˆç†ä½¿ç”¨å†…å­˜ç¼“å­˜æå‡æ€§èƒ½
3. **æµå¼å¤„ç†**: å¤§æ–‡ä»¶å¤„ç†å¿…é¡»æ”¯æŒæµå¼æ“ä½œ
4. **ç”¨æˆ·ä½“éªŒ**: æä¾›å®æ—¶è¿›åº¦åé¦ˆå’Œé”™è¯¯æç¤º

---

**å‚è€ƒæ–‡æ¡£**:
- [è‡ªç ”æ™ºèƒ½ä½“æŠ€æœ¯æŒ‡å¯¼](.kiro/steering/self-developed-agents.md)
- [é¡¹ç›®æ¶æ„è§„èŒƒ](.cursor/rules/01-project-architecture.mdc)
- [æŠ€æœ¯æ ˆå’ŒAIæ¨¡å‹ç®¡ç†è§„èŒƒ](.cursor/rules/08-tech-stack-ai-models.mdc)
- [APIè®¾è®¡æ ‡å‡†](.cursor/rules/06-api-design-standards.mdc)
